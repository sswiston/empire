# THIS CODE IS NOT FULLY COMMENTED

# ellipseMCMC ---------------------------------------------------------

#' @title ellipseMCMC object
#' @description This class stores an object of class "dataTree" and performs an MCMC on the dataTree using a customizeable set of moves.
#' @details If the dataTree provided by the user does not contain initialized data-augmented values for nodes (both W & V), initialized values for model parameters (param), or tip states, values will be simulated.
#' @field dataTree An object of class "dataTree"
#' @field filepath An object of class "character" (a string) that gives the filepath where you want the output log files saved. Default behavior will save the output to the same directory where the mcmc is run.
#' @field prior_sigma_x Prior on the sigma_x model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Uniform(0,1)
#' @field prior_sigma_y Prior on the sigma_y model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Uniform(0,1)
#' @field prior_sigma_r Prior on the sigma_r model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Uniform(0,1)
#' @field prior_sigma_s Prior on the sigma_s model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Uniform(0,1)
#' @field prior_sigma_a Prior on the sigma_a model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Uniform(0,5)
#' @field prior_root_x Prior on the root_x model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Normal(0,1)
#' @field prior_root_y Prior on the root_y model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Normal(0,1)
#' @field prior_root_r Prior on the root_r model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Normal(0,5)
#' @field prior_root_s Prior on the root_s model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Normal(0,5)
#' @field prior_root_a Prior on the root_a model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Uniform(-5,10)
#' @field prior_mu Prior on the mu model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Uniform(-5,10)
#' @field prior_kappa Prior on the kappa model parameter. Should be an object of the type "distribution" generated by using the package "distributions3". Default is Uniform(0,5)
#' @field prob_W The log probability of the data-augmented history of phylogenetic scenarios under the model
#' @field prob_V The log probability of the data-augmented history of r, s, and a values under the model
#' @field prob_XY The log probability of the observed x and y characters under the model
#' @field prob_x The log probability of the observed x character under the model
#' @field prob_y The log probability of the observed y character under the model
#' @field prob_r The log probability of the data-augmented history of r values under the model
#' @field prob_s The log probability of the data-augmented history of s values under the model
#' @field prob_a The log probability of the data-augmented history of a values under the model
#' @field expected_values The expected values of x and y under the model, based on the data-augmented history
#' @field branch_probs The branch-wise probabilities of r, s, and a, based on the data-augmented history
#' @field likelihood The log likelihood of the model under the priors (includes the data-augmented history)
#' @field prior The log prior of the model
#' @field posterior The log posterior of the model
#' @field acceptances A list of lists that keeps track of the number of proposals of each type and the number of acceptances, alongside the acceptance probabilities and proposal hyperparameters (for tuning during burnin)
#' @field proposal_weights A list of MCMC proposals and their relative weights (can use proportions or whole numbers). If you want to exclude a proposal, the weight can be set to 0
#' @field completed_iterations The total number of iterations this MCMC object has completed
#' @field elapsed_time The total amount of time this MCMC has spent running, in hms format (from hms package)
#' @field current_proposal The proposal currently being performed (or last performed) by the MCMC
#' @field testing_conditions A list of extra testing conditions. Options include c("under_prior", "test_probs", "record_proposals")
ellipseMCMC <- R6::R6Class("ellipseMCMC",

# Private Fields & Methods ------------------------------------------------

private = list(

  # Initializing private fields (correspond to active bindings)
  # These fields (starting with '.') are for accessing information internally
  # Active bindings with corresponding names are for accessing information externally
  .dataTree=NULL,
  .filepath=NULL,
  .prior_sigma_x=NULL,
  .prior_sigma_y=NULL,
  .prior_sigma_r=NULL,
  .prior_sigma_s=NULL,
  .prior_sigma_a=NULL,
  .prior_root_x=NULL,
  .prior_root_y=NULL,
  .prior_root_r=NULL,
  .prior_root_s=NULL,
  .prior_root_a=NULL,
  .prior_mu=NULL,
  .prior_kappa=NULL,
  .prob_W=NULL,
  .prob_V=NULL,
  .prob_XY=NULL,
  .prob_x=NULL,
  .prob_y=NULL,
  .prob_r=NULL,
  .prob_s=NULL,
  .prob_a=NULL,
  .expected_values=NULL,
  .branch_probs=NULL,
  .likelihood=NULL,
  .prior=NULL,
  .posterior=NULL,
  .acceptances=NULL,
  .proposal_weights=NULL,
  .completed_iterations=0,
  .elapsed_time=hms::as_hms(0),
  .current_proposal=NULL,
  .testing_conditions=c("none"),

  # These do not correspond to an active binding (cannot be accessed by the user)
  TUNING=NULL, # Whether the MCMC is currently in a burnin period, where tuning is allowed
  PREVIOUS_TIME=NULL, # The time of the previous iteration, used for estimating run times
  UNDER_PRIOR=FALSE, # Testing condition where likelihood is not considered for accepting/rejecting proposals
  TEST_PROBS=FALSE, # Testing condition where full model probabilities are recalculated at every thinning iteration, and compared with sums of branchwise probabilities
  RECORD_PROPOSALS=FALSE, # Testing condition where individual proposals are all recorded

  #' @description Gets the log prior probability of the model from the evolutionary rates (sigma) and root probabilities (pi)
  get_prior = function() {
    # The priors for these model parameters are independent, with their own distributions
    p_sigma_x = distributions3::log_pdf(private$.prior_sigma_x,self$dataTree$param$sigma_x)
    p_sigma_y = distributions3::log_pdf(private$.prior_sigma_y,self$dataTree$param$sigma_y)
    p_sigma_r = distributions3::log_pdf(private$.prior_sigma_r,self$dataTree$param$sigma_r)
    p_sigma_s = distributions3::log_pdf(private$.prior_sigma_s,self$dataTree$param$sigma_s)
    p_sigma_a = distributions3::log_pdf(private$.prior_sigma_a,self$dataTree$param$sigma_a)
    p_root_x = distributions3::log_pdf(private$.prior_root_x,self$dataTree$param$root_x)
    p_root_y = distributions3::log_pdf(private$.prior_root_y,self$dataTree$param$root_y)
    p_root_r = distributions3::log_pdf(private$.prior_root_r,self$dataTree$param$root_r)
    p_root_s = distributions3::log_pdf(private$.prior_root_s,self$dataTree$param$root_s)
    p_root_a = distributions3::log_pdf(private$.prior_root_a,self$dataTree$param$root_a)
    p_mu = distributions3::log_pdf(private$.prior_mu,self$dataTree$param$mu)
    p_kappa = distributions3::log_pdf(private$.prior_kappa,self$dataTree$param$kappa)
    # Since this is a log probability, the individual prior probabilities are summed
    prior <- p_sigma_x + p_sigma_y + p_sigma_r + p_sigma_s + p_sigma_a + p_root_x + p_root_y + p_root_r + p_root_s + p_root_a + p_mu + p_kappa
    # THIS IS A LOG PROBABILITY
    return(prior)
  },

  #' @description Calculates a new log prior probability when given a new value for one parameter (used in proposals)
  #' @param new_val The new value of a parameter (numeric)
  #' @param name The name of the parameter being updated (character)
  get_new_prior = function(new_val, name) {
    # this is the name of the prior distribution
    full_name = paste0("prior_",name)
    # this is the current value of the parameter being updated
    current_val = self$dataTree$param[[name]]
    # getting the prior probability of the current value of the parameter
    p_current = distributions3::log_pdf(self[[full_name]],current_val)
    # getting the prior probability of the new value of the parameter
    p_new = distributions3::log_pdf(self[[full_name]],new_val)
    # getting the new total prior by subtracting out the contribution from the previous parameter value and adding the contribution from the new parameter value
    new_prior = private$.prior - p_current + p_new
    # THIS IS A LOG PROBABILITY
    return(new_prior)
  },

  #' @description Proposes an MCMC move, returning TRUE if the proposal should be accepted and FALSE if the proposal should not be accepted
  #' @param prior The current prior probability of the model
  #' @param new_prior The new prior probability of the model if the proposal is accepted
  #' @param likelihood The current likelihood of the model
  #' @param new_likelihood The new likelihood of the model if the proposal is accepted
  propose = function(prior, new_prior, likelihood, new_likelihood) {
    # Due to proposal setup, infinite or NA likelihoods should not occur
    # But for safety, we will always reject them
    # Infinite likelihoods or priors are usually the result of out-of-bounds parameters (outside their allowed distributions)
    # NA likelihoods or priors are usually the result of failed projection equations, typically from unusually large or small values for a, r, or s
    if (is.infinite(new_likelihood)) {return(FALSE)}
    if (is.infinite(new_prior)) {return(FALSE)}
    if (is.na(new_likelihood)) {return(FALSE)}
    if (is.na(new_prior)) {return(FALSE)}
    # Metropolis-Hastings
    if (private$UNDER_PRIOR == FALSE) {
      ln_mh_ratio <- new_likelihood-likelihood+new_prior-prior
      if (private$RECORD_PROPOSALS) {cat(paste0(paste(private$.current_proposal, prior, new_prior, likelihood, new_likelihood, ln_mh_ratio, sep=","), "\n"), file=paste0(self$filepath,"/ln_mh_ratio.txt"),append=TRUE)}
    } else {
      ln_mh_ratio <- new_prior-prior # Under the prior, we don't want the likelihood to contribute to acceptance probabilities
      if (private$RECORD_PROPOSALS) {cat(paste0(paste(private$.current_proposal, prior, new_prior, likelihood, new_likelihood, ln_mh_ratio, sep=","), "\n"), file=paste0(self$filepath,"/ln_mh_ratio.txt"),append=TRUE)}
    }
    # Automatically rejecting very improbable proposals
    if (ln_mh_ratio <= -250) {return(FALSE)}
    R <- exp(ln_mh_ratio)
    u <- runif(1,0,1)
    return(u < R)
  },

  #' @description Chooses a random proposal for a particular move given the proposal weights. Some of these "proposals" are actually multi-proposal moves that schedule a series of proposals on a set of model components or nodes. As an example, a "proposal" on data-augmented value 'r' at an internal node will schedule several individual 'r' proposals for nodes nearby the target node, to take place consecutively. These are different from "joint" proposals, which update multiple values before calculating a new likelihood and accepting/rejecting. This model does not incorporate any joint proposals.
  choose_proposal = function() {
    # Weights can be presented as proportions OR whole numbers, and do not have to sum to 1
    sum_proposal_weights = sum(unlist(self$proposal_weights))
    # Picking a value associated with a proposal
    # This gives a value, but have to see which proposal is associated with that value...
    proposal_val = runif(1,0,sum_proposal_weights)
    current_weight = 0
    proposal_number = 1
    # Looping through all proposals to identify proposal associated with value
    for (i in 1:length(self$proposal_weights)) {
      if (proposal_val <= self$proposal_weights[[i]] + current_weight) {break} # If the proposal value is contained in the current interval (less than the endpoint of the interval), we select it
      current_weight <- current_weight + self$proposal_weights[[i]] # If not, we move on to the next interval
      proposal_number <- proposal_number + 1
    }
    # Returning the name of the proposal (used to call MCMC move)
    return(names(self$proposal_weights[proposal_number]))
  },

  #' @description Performs a single proposal by choosing a proposal type and calling the relevant proposal function
  do_proposal = function() {
    # Picking a proposal from the list of possible proposals according to proposal weight
    proposal_name = private$choose_proposal()
    # If we are using the testing condition for recording proposals, we output the name of the current proposal to screen
    if (private$RECORD_PROPOSALS) {print(proposal_name)}
    # We keep track of the proposal being performed (or the most recent proposal that was performed)
    private$.current_proposal <- proposal_name
    # Depending on the proposal that is selected, we call the corresponding proposal function to actually do the proposal
    if (proposal_name == "sigma_x") {private$propose_sigma_x()}
    if (proposal_name == "sigma_y") {private$propose_sigma_y()}
    if (proposal_name == "sigma_r") {private$propose_sigma_r()}
    if (proposal_name == "sigma_s") {private$propose_sigma_s()}
    if (proposal_name == "sigma_a") {private$propose_sigma_a()}
    if (proposal_name == "root_x") {private$propose_root_x()}
    if (proposal_name == "root_y") {private$propose_root_y()}
    if (proposal_name == "root_r") {private$propose_root_r()}
    if (proposal_name == "root_s") {private$propose_root_s()}
    if (proposal_name == "root_a") {private$propose_root_a()}
    if (proposal_name == "mu") {private$propose_mu()}
    if (proposal_name == "kappa") {private$propose_kappa()}
    if (proposal_name == "W_d") {private$propose_w_d()}
    if (proposal_name == "W_m") {private$propose_w_m()}
    if (proposal_name == "W_c") {private$propose_w_c()}
    if (proposal_name == "W_h") {private$propose_w_h()}
    if (proposal_name == "V_r") {private$propose_v_r()}
    if (proposal_name == "V_s") {private$propose_v_s()}
    if (proposal_name == "V_a") {private$propose_v_a()}
    if (proposal_name == "tip") {private$propose_tip()}
  },

  #' @description Gets nodes local to a selected node, returns node indices for parent / node / children / grands / greats (if they exist & are available for proposals) in random order
  #' @param target_node The node index for the selected node
  #' @param category "W" or "V" (determines whether or not to return the root as well; root proposals on W are allowed here, but root proposals on V are performed through a separate function)
  get_local = function(target_node,category) {
    # Getting the parent of our target node
    parent <- self$dataTree$tree$nodes[[target_node,2]]
    # Getting the children of our target node
    children <- as.vector(unlist(self$dataTree$tree$nodes[target_node,3:4]))
    # Getting the grands of the target node (if the children exist)
    grands <- c()
    for (i in 1:length(children)) {if (!is.na(children[i])) {grands <- c(grands,as.vector(unlist(self$dataTree$tree$nodes[children[i],3:4])))}}
    # Getting the great grands of the target node (if the grands exist)
    greats <- c()
    for (i in 1:length(grands)) {if (!is.na(grands[i])) {greats <- c(greats,as.vector(unlist(self$dataTree$tree$nodes[grands[i],3:4])))}}
    # Putting together the target node with its parent, children, grands, and greats
    nodes <- c(parent,target_node,children,grands,greats)
    # Removing any non-existing nodes
    nodes <- nodes[!is.na(nodes)]
    # Removing any tip nodes
    nodes <- nodes[nodes > self$dataTree$tree$n_tips]
    # Removing the root node if we are proposing on V
    if (category=="V") {
      nodes <- nodes[nodes != (self$dataTree$tree$n_tips+1)]
    }
    # If we find more than 1 node, we put them in a random order
    if (length(nodes) > 1) {indices <- sample(nodes, length(nodes))} else {indices <- nodes}
    return(indices)
  },

  #' @description Gets probability of x given expected values and sigma_x
  #' @param x_expected The expected values for x
  #' @param sigma_x The sigma_x parameter
  get_prob_x = function(x_expected,sigma_x) {
    n_tips <- self$dataTree$tree$n_tips
    inv <- self$dataTree$tree$inv_matrix
    matrix <- self$dataTree$tree$phy_matrix
    matrix_det <- unlist(determinant(matrix,logarithm=TRUE))[[1]]
    x_data <- t(as.matrix(self$dataTree$XY$x))[1:n_tips]
    x <- x_data - x_expected
    new_prob_x <- (-1/2) * (length(x) * log(2 * pi) + length(x) * 2 * log(sigma_x) + matrix_det + x %*% ((1 / sigma_x^2) * inv) %*% t(x))
    return(new_prob_x)
  },

  #' @description Gets probability of y given expected values and sigma_y
  #' @param y_expected The expected values for y
  #' @param sigma_y The sigma_y parameter
  get_prob_y = function(y_expected,sigma_y) {
    n_tips <- self$dataTree$tree$n_tips
    inv <- self$dataTree$tree$inv_matrix
    matrix <- self$dataTree$tree$phy_matrix
    matrix_det <- unlist(determinant(matrix,logarithm=TRUE))[[1]]
    y_data <- t(as.matrix(self$dataTree$XY$y))[1:n_tips]
    y <- y_data - y_expected
    new_prob_y <- (-1/2) * (length(y) * log(2 * pi) + length(y) * 2 * log(sigma_y) + matrix_det + y %*% ((1 / sigma_y^2) * inv) %*% t(y))
    return(new_prob_y)
  },

  #' @description Gets branch probability for r or s given start, end, length, and sigma
  #' @param start The value at the start of the branch
  #' @param end The value at the end of the branch
  #' @param length The lenght of the branch
  #' @param sigma The sigma parameter
  get_branch_prob_rs = function(start,end,length,sigma) {
    branch_prob <- dnorm(end, start, sigma*sqrt(length),log=TRUE)
    return(branch_prob)
  },

  #' @description Gets branch probability for a given start, end, length, sigma, mu, and kappa
  #' @param start The value at the start of the branch
  #' @param end The value at the end of the branch
  #' @param length The lenght of the branch
  #' @param sigma The sigma parameter
  #' @param mu The mu parameter
  #' @param kappa The kappa parameter
  get_branch_prob_a = function(start,end,length,sigma,mu,kappa) {
    branch_prob <- dnorm(end, mu + (start - mu) * exp(-1 * kappa * length), sqrt(sigma^2 / (2 * kappa) * (1 - exp(-2 * kappa * length))),log=TRUE)
    return(branch_prob)
  },

  #' @description Tests whether tracked probabilities are equal to the total probabilities calculated from model parameters and data-augmented values
  test_probs = function() {
    true_prob_w <- round(get_prob_w(self$dataTree),3)
    true_prob_v <- round(get_prob_v(self$dataTree),3)
    true_prob_xy <- round(get_prob_xy(self$dataTree),3)
    tracked_prob_w <- round(self$prob_W,3)
    tracked_prob_v <- round(self$prob_V,3)
    tracked_prob_xy <- round(self$prob_XY,3)
    if (true_prob_w != tracked_prob_w) {cat(paste0("Something went wrong with proposal ",private$.current_proposal," -- True W Probability: ",true_prob_w," | Tracked W Probability: ",tracked_prob_w,"\n"))}
    if (true_prob_v != tracked_prob_v) {cat(paste0("Something went wrong with proposal ",private$.current_proposal," -- True V Probability: ",true_prob_v," | Tracked V Probability: ",tracked_prob_v,"\n"))}
    if (true_prob_xy != tracked_prob_xy) {cat(paste0("Something went wrong with proposal ",private$.current_proposal," -- True XY Probability: ",true_prob_xy," | Tracked XY Probability: ",tracked_prob_xy,"\n"))}
  },

  #' @description Saves an iteration (if the iteration is not thinned)
  save_iteration = function(length_W,length_V,length_XY,iteration,thinning,iterations) {
    if (((private$.completed_iterations+1) / thinning) == round((private$.completed_iterations+1) / thinning)) {
      # Computing elapsed time
      systime = Sys.time()
      print_time = hms::as_hms(round(systime) - round(private$PREVIOUS_TIME) + round(private$.elapsed_time))
      diftime = hms::as_hms(systime - private$PREVIOUS_TIME)
      private$.elapsed_time = hms::as_hms(diftime + private$.elapsed_time)
      eta = hms::as_hms(round((private$.elapsed_time * (iterations / iteration)) - private$.elapsed_time))
      private$PREVIOUS_TIME = systime
      # Printing current values to screen
      screen_str = paste(iteration,round(private$.posterior,3),round(private$.likelihood,3),round(private$.prior,3),round(self$dataTree$param$sigma_x,3),round(self$dataTree$param$sigma_y,3),round(self$dataTree$param$sigma_r,3),round(self$dataTree$param$sigma_s,3),round(self$dataTree$param$sigma_a,3),round(self$dataTree$param$root_x,3),round(self$dataTree$param$root_y,3),round(self$dataTree$param$root_r,3),round(self$dataTree$param$root_s,3),round(self$dataTree$param$root_a,3),round(self$dataTree$param$mu,3),round(self$dataTree$param$kappa,3),print_time,eta,sep="\t")
      cat(screen_str,"\n")
      # Adding current values to logfile
      out_str = paste(iteration,private$.posterior,private$.likelihood,private$.prior,self$dataTree$param$sigma_x,self$dataTree$param$sigma_y,self$dataTree$param$sigma_r,self$dataTree$param$sigma_s,self$dataTree$param$sigma_a,self$dataTree$param$root_x,self$dataTree$param$root_y,self$dataTree$param$root_r,self$dataTree$param$root_s,self$dataTree$param$root_a,self$dataTree$param$mu,self$dataTree$param$kappa,print_time,eta,sep="\t")
      write(out_str,paste0(self$filepath,"/model_log.tsv"),append=TRUE)
      write(c(iteration,self$dataTree$W$h),paste0(self$filepath,"/h_log.tsv"),ncolumns=(1+length_W),sep="\t",append=TRUE)
      write(c(iteration,self$dataTree$W$c),paste0(self$filepath,"/c_log.tsv"),ncolumns=(1+length_W),sep="\t",append=TRUE)
      write(c(iteration,self$dataTree$W$m),paste0(self$filepath,"/m_log.tsv"),ncolumns=(1+length_W),sep="\t",append=TRUE)
      write(c(iteration,self$dataTree$W$d),paste0(self$filepath,"/d_log.tsv"),ncolumns=(1+length_W),sep="\t",append=TRUE)
      write(c(iteration,self$dataTree$V$r),paste0(self$filepath,"/r_log.tsv"),ncolumns=(1+length_V),sep="\t",append=TRUE)
      write(c(iteration,self$dataTree$V$s),paste0(self$filepath,"/s_log.tsv"),ncolumns=(1+length_V),sep="\t",append=TRUE)
      write(c(iteration,self$dataTree$V$a),paste0(self$filepath,"/a_log.tsv"),ncolumns=(1+length_V),sep="\t",append=TRUE)
      write(c(iteration,self$dataTree$XY$x),paste0(self$filepath,"/x_log.tsv"),ncolumns=(1+length_XY),sep="\t",append=TRUE)
      write(c(iteration,self$dataTree$XY$y),paste0(self$filepath,"/y_log.tsv"),ncolumns=(1+length_XY),sep="\t",append=TRUE)
      acceptance_data <- as.data.frame(rbind(sigma_x=as.character(self$acceptances$sigma_x),
                                             sigma_y=as.character(self$acceptances$sigma_y),
                                             sigma_r=as.character(self$acceptances$sigma_r),
                                             sigma_s=as.character(self$acceptances$sigma_s),
                                             sigma_a=as.character(self$acceptances$sigma_a),
                                             root_x=as.character(self$acceptances$root_x),
                                             root_y=as.character(self$acceptances$root_y),
                                             root_r=as.character(self$acceptances$root_r),
                                             root_s=as.character(self$acceptances$root_s),
                                             root_a=as.character(self$acceptances$root_a),
                                             W_d=as.character(self$acceptances$W_d),
                                             W_m=as.character(self$acceptances$W_m),
                                             W_c=as.character(self$acceptances$W_c),
                                             W_h=as.character(self$acceptances$W_h),
                                             V_r=as.character(self$acceptances$V_r),
                                             V_s=as.character(self$acceptances$V_s),
                                             V_a=as.character(self$acceptances$V_a),
                                             tip=as.character(self$acceptances$tip),
                                             mu=as.character(self$acceptances$mu),
                                             kappa=as.character(self$acceptances$kappa)))
      names <- rownames(acceptance_data)
      acceptance_data <- cbind(names,acceptance_data)
      colnames(acceptance_data) <- c("proposal","proposed","accepted","accumulated","current_prob","hyperparam")
      write.table(acceptance_data,paste0(self$filepath,"/acceptances.tsv"),sep="\t",quote=FALSE,row.names=FALSE,col.names=TRUE)
    }
    # Adding the iteration to completed iterations
    private$.completed_iterations = private$.completed_iterations + 1
  },

  #' @description Tunes hyperparameters (if appropriate)
  #' @param accept Whether the most recent proposal was accepted
  tune = function(accept) {
    # Getting the current proposal
    proposal_name <- private$.current_proposal
    # Tracking that the proposal happened
    private$.acceptances[[proposal_name]]$proposed = private$.acceptances[[proposal_name]]$proposed + 1
    # Tracking whether an acceptance happened
    if (accept) {private$.acceptances[[proposal_name]]$accepted = private$.acceptances[[proposal_name]]$accepted + 1}
    # If burnin is happening, potentially tune proposal hyperparameter
    if (private$TUNING) {
      # If the move was accepted, add it to the "accumulated acceptances", which represent acceptances for this set of 100 iterations
      if (accept) {private$.acceptances[[proposal_name]]$accumulated = private$.acceptances[[proposal_name]]$accumulated + 1}
      # Check if this is an iteration for tuning -- this happens every 100 proposals for a specific parameter
      if (private$.acceptances[[proposal_name]]$proposed %% 100 == 0) {
        # Calculate the acceptance probability for this set of 100 iterations
        acceptance_ratio <- private$.acceptances[[proposal_name]]$accumulated / 100
        private$.acceptances[[proposal_name]]$current_prob = acceptance_ratio
        # Check if this is a parameter with a hyperparameter to be tuned
        if (!is.null(private$.acceptances[[proposal_name]]$hyperparam)) {
          # We are targeting an acceptance ratio between 0.2 and 0.4 -- anything outside this range will result in tuning
          current_hyperparam <- private$.acceptances[[proposal_name]]$hyperparam
          new_hyperparam <- current_hyperparam
          if (acceptance_ratio > 0.4) {new_hyperparam <- current_hyperparam * 1.1} # If we are accepting too many proposals, we need more dramatic proposals
          if (acceptance_ratio < 0.2) {new_hyperparam <- current_hyperparam * 0.9} # If we are not accepting enough proposals, we need less dramatic proposals
          private$.acceptances[[proposal_name]]$hyperparam = new_hyperparam
        }
        # Clear the accumulated proposals to start over for the next 100 proposals
        private$.acceptances[[proposal_name]]$accumulated = 0
      }
    }
  },

  #' @description Performs a proposal on sigma_x
  propose_sigma_x = function() {

    # PARAMETER UPDATES: sigma_x
    # Getting current value
    current_val = self$dataTree$param$sigma_x
    # Suggesting a new value
    hyperparam = private$.acceptances$sigma_x$hyperparam
    new_val <- current_val + runif(1,-1*hyperparam,hyperparam)

    # PROBABILTIY UPDATES
    if (new_val <= 0) {accept <- FALSE} else {
      # W: None
      # V: None
      # XY: prob_x, prob_xy
      x_expected <- t(as.matrix(self$expected_values[,1]))
      new_prob_x <- private$get_prob_x(x_expected,new_val)
      new_prob_xy <- private$.prob_y + new_prob_x
      new_likelihood <- private$.prob_W + private$.prob_V + new_prob_xy
      # PRIOR
      new_prior <- private$get_new_prior(new_val, "sigma_x")
      # PROPOSAL
      accept <- private$propose(private$.prior, new_prior, private$.likelihood, new_likelihood)
      if (accept) {
        # Updating real values
        self$dataTree$param$sigma_x <- new_val
        private$.prob_x <- new_prob_x
        private$.prob_XY <- new_prob_xy
        private$.likelihood <- new_likelihood
        private$.prior <- new_prior
        private$.posterior <- private$.prior + private$.likelihood
        # MCMC OBJECTS: None
      }
    }

    private$tune(accept)

  },

  #' @description Performs a proposal on sigma_y
  propose_sigma_y = function() {

    # PARAMETER UPDATES: sigma_y
    # Getting current value
    current_val = self$dataTree$param$sigma_y
    # Suggesting a new value
    hyperparam = private$.acceptances$sigma_y$hyperparam
    new_val <- current_val + runif(1,-1*hyperparam,hyperparam)

    # PROBABILTIY UPDATES
    if (new_val <= 0) {accept <- FALSE} else {
      # W: None
      # V: None
      # XY: prob_y, prob_xy
      y_expected <- t(as.matrix(self$expected_values[,2]))
      new_prob_y <- private$get_prob_y(y_expected,new_val)
      new_prob_xy <- private$.prob_x + new_prob_y
      new_likelihood <- private$.prob_W + private$.prob_V + new_prob_xy
      # MCMC OBJECTS: None
      # PRIOR
      new_prior <- private$get_new_prior(new_val, "sigma_y")
      # PROPOSAL
      accept <- private$propose(private$.prior, new_prior, private$.likelihood, new_likelihood)
      if (accept) {
        # Updating real values
        self$dataTree$param$sigma_y <- new_val
        private$.prob_y <- new_prob_y
        private$.prob_XY <- new_prob_xy
        private$.likelihood <- new_likelihood
        private$.prior <- new_prior
        private$.posterior <- private$.prior + private$.likelihood
        # MCMC OBJECTS: None
      }
    }

    private$tune(accept)

  },

  #' @description Performs a proposal on sigma_r
  propose_sigma_r = function() {

    # PARAMETER UPDATES: sigma_r
    # Getting current value
    current_val = self$dataTree$param$sigma_r
    # Suggesting a new value
    hyperparam = private$.acceptances$sigma_r$hyperparam
    new_val <- current_val + runif(1,-1*hyperparam,hyperparam)

    # PROBABILTIY UPDATES
    if (new_val <= 0) {accept <- FALSE} else {
      # W: None
      # V: prob_r, prob_v
      new_probs <- c()
      for (i in 1:length(self$branch_probs$start_node)) {
        start_r <- self$branch_probs$start_r[i]
        end_r <- self$branch_probs$end_r[i]
        length <- self$branch_probs$length[i]
        new_probs <- c(new_probs,private$get_branch_prob_rs(start_r,end_r,length,new_val))
      }
      new_prob_r <- sum(new_probs)
      new_prob_v <- new_prob_r + private$.prob_s + private$.prob_a
      new_likelihood <- private$.prob_W + new_prob_v + private$.prob_XY
      # XY: None
      # PRIOR
      new_prior <- private$get_new_prior(new_val, "sigma_r")
      # PROPOSAL
      accept <- private$propose(private$.prior, new_prior, private$.likelihood, new_likelihood)
      if (accept) {
        # Updating real values
        self$dataTree$param$sigma_r <- new_val
        private$.prob_r <- new_prob_r
        private$.prob_V <- new_prob_v
        private$.likelihood <- new_likelihood
        private$.prior <- new_prior
        private$.posterior <- private$.prior + private$.likelihood
        # MCMC OBJECTS: branch_probs$prob_r
        private$.branch_probs$prob_r <- new_probs
      }
    }

    private$tune(accept)

  },

  #' @description Performs a proposal on sigma_s
  propose_sigma_s = function() {

    # PARAMETER UPDATES: sigma_s
    # Getting current value
    current_val = self$dataTree$param$sigma_s
    # Suggesting a new value
    hyperparam = private$.acceptances$sigma_s$hyperparam
    new_val <- current_val + runif(1,-1*hyperparam,hyperparam)

    # PROBABILTIY UPDATES
    if (new_val <= 0) {accept <- FALSE} else {
      # W: None
      # V: prob_s, prob_v
      new_probs <- c()
      for (i in 1:length(self$branch_probs$start_node)) {
        start_s <- self$branch_probs$start_s[i]
        end_s <- self$branch_probs$end_s[i]
        length <- self$branch_probs$length[i]
        new_probs <- c(new_probs,private$get_branch_prob_rs(start_s,end_s,length,new_val))
      }
      new_prob_s <- sum(new_probs)
      new_prob_v <- private$.prob_r + new_prob_s + private$.prob_a
      new_likelihood <- private$.prob_W + new_prob_v + private$.prob_XY
      # XY: None
      # PRIOR
      new_prior <- private$get_new_prior(new_val, "sigma_s")
      # PROPOSAL
      accept <- private$propose(private$.prior, new_prior, private$.likelihood, new_likelihood)
      if (accept) {
        # Updating real values
        self$dataTree$param$sigma_s <- new_val
        private$.prob_s <- new_prob_s
        private$.prob_V <- new_prob_v
        private$.likelihood <- new_likelihood
        private$.prior <- new_prior
        private$.posterior <- private$.prior + private$.likelihood
        # MCMC OBJECTS: branch_probs$prob_r
        private$.branch_probs$prob_s <- new_probs
      }
    }

    private$tune(accept)

  },

  #' @description Performs a proposal on sigma_a
  propose_sigma_a = function() {

    # PARAMETER UPDATES: sigma_a
    # Getting current value
    current_val = self$dataTree$param$sigma_a
    # Suggesting a new value
    hyperparam = private$.acceptances$sigma_a$hyperparam
    new_val <- current_val + runif(1,-1*hyperparam,hyperparam)

    # PROBABILTIY UPDATES
    if (new_val <= 0) {accept <- FALSE} else {
      # W: None
      # V: prob_a, prob_v
      new_probs <- c()
      for (i in 1:length(self$branch_probs$start_node)) {
        start_a <- self$branch_probs$start_a[i]
        end_a <- self$branch_probs$end_a[i]
        length <- self$branch_probs$length[i]
        mu <- self$dataTree$param$mu
        kappa <- self$dataTree$param$kappa
        new_probs <- c(new_probs,private$get_branch_prob_a(start_a,end_a,length,new_val,mu,kappa))
      }
      new_prob_a <- sum(new_probs)
      new_prob_v <- private$.prob_r + private$.prob_s + new_prob_a
      new_likelihood <- private$.prob_W + new_prob_v + private$.prob_XY
      # XY: None
      # PRIOR
      new_prior <- private$get_new_prior(new_val, "sigma_a")
      # PROPOSAL
      accept <- private$propose(private$.prior, new_prior, private$.likelihood, new_likelihood)
      if (accept) {
        # Updating real values
        self$dataTree$param$sigma_a <- new_val
        private$.prob_a <- new_prob_a
        private$.prob_V <- new_prob_v
        private$.likelihood <- new_likelihood
        private$.prior <- new_prior
        private$.posterior <- private$.prior + private$.likelihood
        # MCMC OBJECTS: branch_probs$prob_a
        private$.branch_probs$prob_a <- new_probs
      }
    }

    private$tune(accept)

  },

  #' @description Performs a proposal on kappa
  propose_kappa = function() {

    # PARAMETER UPDATES: kappa
    # Getting current value
    current_val = self$dataTree$param$kappa
    # Suggesting a new value
    hyperparam = private$.acceptances$kappa$hyperparam
    new_val <- current_val + runif(1,-1*hyperparam,hyperparam)

    # PROBABILTIY UPDATES
    if (new_val <= 0) {accept <- FALSE} else {
      # W: None
      # V: prob_a, prob_v
      new_probs <- c()
      for (i in 1:length(self$branch_probs$start_node)) {
        start_a <- self$branch_probs$start_a[i]
        end_a <- self$branch_probs$end_a[i]
        length <- self$branch_probs$length[i]
        sigma <- self$dataTree$param$sigma_a
        mu <- self$dataTree$param$mu
        new_probs <- c(new_probs,private$get_branch_prob_a(start_a,end_a,length,sigma,mu,new_val))
      }
      new_prob_a <- sum(new_probs)
      new_prob_v <- private$.prob_r + private$.prob_s + new_prob_a
      new_likelihood <- private$.prob_W + new_prob_v + private$.prob_XY
      # XY: None
      # PRIOR
      new_prior <- private$get_new_prior(new_val, "kappa")
      # PROPOSAL
      accept <- private$propose(private$.prior, new_prior, private$.likelihood, new_likelihood)
      if (accept) {
        # Updating real values
        self$dataTree$param$kappa <- new_val
        private$.prob_a <- new_prob_a
        private$.prob_V <- new_prob_v
        private$.likelihood <- new_likelihood
        private$.prior <- new_prior
        private$.posterior <- private$.prior + private$.likelihood
        # MCMC OBJECTS: branch_probs$prob_a
        private$.branch_probs$prob_a <- new_probs
      }
    }

    private$tune(accept)

  },

  #' @description Performs a proposal on mu
  propose_mu = function() {

    # PARAMETER UPDATES: mu
    # Getting current value
    current_val = self$dataTree$param$mu
    # Suggesting a new value
    hyperparam = private$.acceptances$mu$hyperparam
    new_val <- current_val + runif(1,-1*hyperparam,hyperparam)

    # PROBABILTIY UPDATES
    # W: None
    # V: prob_a, prob_v
    new_probs <- c()
    for (i in 1:length(self$branch_probs$start_node)) {
      start_a <- self$branch_probs$start_a[i]
      end_a <- self$branch_probs$end_a[i]
      length <- self$branch_probs$length[i]
      sigma <- self$dataTree$param$sigma_a
      kappa <- self$dataTree$param$kappa
      new_probs <- c(new_probs,private$get_branch_prob_a(start_a,end_a,length,sigma,new_val,kappa))
    }
    new_prob_a <- sum(new_probs)
    new_prob_v <- private$.prob_r + private$.prob_s + new_prob_a
    new_likelihood <- private$.prob_W + new_prob_v + private$.prob_XY
    # XY: None
    # PRIOR
    new_prior <- private$get_new_prior(new_val, "mu")
    # PROPOSAL
    accept <- private$propose(private$.prior, new_prior, private$.likelihood, new_likelihood)
    if (accept) {
      # Updating real values
      self$dataTree$param$mu <- new_val
      private$.prob_a <- new_prob_a
      private$.prob_V <- new_prob_v
      private$.likelihood <- new_likelihood
      private$.prior <- new_prior
      private$.posterior <- private$.prior + private$.likelihood
      # MCMC OBJECTS: branch_probs$prob_a
      private$.branch_probs$prob_a <- new_probs
    }

    private$tune(accept)

  },

  #' @description Performs a proposal on root_x
  propose_root_x = function() {

    # PARAMETER UPDATES: root_x
    # Getting current value
    current_val = self$dataTree$param$root_x
    # Suggesting a new value
    hyperparam = private$.acceptances$root_x$hyperparam
    new_val <- current_val + runif(1,-1*hyperparam,hyperparam)

    # PROBABILTIY UPDATES
    # W: None
    # V: None
    # XY: prob_x, prob_xy
    new_x_expected <- t(as.matrix(self$expected_values[,1])) - current_val + new_val
    sigma <- self$dataTree$param$sigma_x
    new_prob_x <- private$get_prob_x(new_x_expected,sigma)
    new_prob_xy <- private$.prob_y + new_prob_x
    new_likelihood <- private$.prob_W + private$.prob_V + new_prob_xy
    # PRIOR
    new_prior <- private$get_new_prior(new_val, "root_x")
    # PROPOSAL
    accept <- private$propose(private$.prior, new_prior, private$.likelihood, new_likelihood)
    if (accept) {
      # Updating real values
      self$dataTree$param$root_x <- new_val
      self$dataTree$XY$x[self$dataTree$tree$n_tips + 1] <- new_val
      private$.prob_x <- new_prob_x
      private$.prob_XY <- new_prob_xy
      private$.likelihood <- new_likelihood
      private$.prior <- new_prior
      private$.posterior <- private$.prior + private$.likelihood
      # MCMC OBJECTS: expected_values$x
      private$.expected_values$x <- t(new_x_expected)
    }

    private$tune(accept)

  },

  #' @description Performs a proposal on root_y
  propose_root_y = function() {

    # PARAMETER UPDATES: root_y
    # Getting current value
    current_val = self$dataTree$param$root_y
    # Suggesting a new value
    hyperparam = private$.acceptances$root_y$hyperparam
    new_val <- current_val + runif(1,-1*hyperparam,hyperparam)

    # PROBABILTIY UPDATES
    # W: None
    # V: None
    # XY: prob_y, prob_xy
    new_y_expected <- t(as.matrix(self$expected_values[,2])) - current_val + new_val
    sigma <- self$dataTree$param$sigma_y
    new_prob_y <- private$get_prob_y(new_y_expected,sigma)
    new_prob_xy <- private$.prob_x + new_prob_y
    new_likelihood <- private$.prob_W + private$.prob_V + new_prob_xy
    # PRIOR
    new_prior <- private$get_new_prior(new_val, "root_y")
    # PROPOSAL
    accept <- private$propose(private$.prior, new_prior, private$.likelihood, new_likelihood)
    if (accept) {
      # Updating real values
      self$dataTree$param$root_y <- new_val
      self$dataTree$XY$y[self$dataTree$tree$n_tips + 1] <- new_val
      private$.prob_y <- new_prob_y
      private$.prob_XY <- new_prob_xy
      private$.likelihood <- new_likelihood
      private$.prior <- new_prior
      private$.posterior <- private$.prior + private$.likelihood
      # MCMC OBJECTS: expected_values$y
      private$.expected_values$y <- t(new_y_expected)
    }

    private$tune(accept)

  },

  #' @description Performs a proposal on root_r
  propose_root_r = function() {

    # PARAMETER UPDATES: root_r
    # Getting current value
    current_val = self$dataTree$param$root_r
    # Suggesting a new value
    hyperparam = private$.acceptances$root_r$hyperparam
    new_val <- current_val + runif(1,-1*hyperparam,hyperparam)

    # PROBABILTIY UPDATES
    if (abs(new_val) >= 100) {accept <- FALSE} else {
      # W: None
      # V: prob_r, prob_v
      root <- self$dataTree$tree$n_tips + 1
      row_left <- which(self$branch_probs$start_node == root & self$branch_probs$child == "left")
      row_right <- which(self$branch_probs$start_node == root & self$branch_probs$child == "right")
      length_left <- self$branch_probs$length[row_left]
      length_right <- self$branch_probs$length[row_right]
      end_left <- self$branch_probs$end_r[row_left]
      end_right <- self$branch_probs$end_r[row_right]
      current_branch_prob_left <- self$branch_probs$prob_r[row_left]
      current_branch_prob_right <- self$branch_probs$prob_r[row_right]
      sigma_r <- self$dataTree$param$sigma_r
      new_branch_prob_left <- private$get_branch_prob_rs(new_val,end_left,length_left,sigma_r)
      new_branch_prob_right <- private$get_branch_prob_rs(new_val,end_right,length_right,sigma_r)
      new_prob_r <- private$.prob_r - current_branch_prob_left - current_branch_prob_right + new_branch_prob_left + new_branch_prob_right
      new_prob_v <- private$.prob_a + private$.prob_s + new_prob_r
      # XY: prob_x, prob_y, prob_xy
      current_proj_x_left <- self$branch_probs$proj_x[row_left]
      current_proj_x_right <- self$branch_probs$proj_x[row_right]
      current_proj_y_left <- self$branch_probs$proj_y[row_left]
      current_proj_y_right <- self$branch_probs$proj_y[row_right]
      d <- self$dataTree$W$d[1]
      m <- self$dataTree$W$m[1]
      cval <- self$dataTree$W$cval[1]
      hval <- self$dataTree$W$hval[1]
      s <- self$dataTree$V$s[root]
      a <- self$dataTree$V$a[root]
      z <- self$dataTree$param$z
      new_proj_x_left <- transform_node(char="x", daughter="left", d=d, m=m, c=cval, h=hval, x=0, r=new_val, s=s, a=a, z=z)
      new_proj_x_right <- transform_node(char="x", daughter="right", d=d, m=m, c=cval, h=hval, x=0, r=new_val, s=s, a=a, z=z)
      new_proj_y_left <- transform_node(char="y", daughter="left", d=d, m=m, c=cval, h=hval, y=0, r=new_val, s=s, a=a, z=z)
      new_proj_y_right <- transform_node(char="y", daughter="right", d=d, m=m, c=cval, h=hval, y=0, r=new_val, s=s, a=a, z=z)
      tips_left <- which(self$dataTree$tree$tip_descendants[self$branch_probs$end_node[row_left],]==1)
      tips_right <- which(self$dataTree$tree$tip_descendants[self$branch_probs$end_node[row_right],]==1)
      new_expected_values <- self$expected_values
      for (i in tips_left) {
        new_expected_values$x[i] <- self$expected_values$x[i] - current_proj_x_left + new_proj_x_left
        new_expected_values$y[i] <- self$expected_values$y[i] - current_proj_y_left + new_proj_y_left
      }
      for (i in tips_right) {
        new_expected_values$x[i] <- self$expected_values$x[i] - current_proj_x_right + new_proj_x_right
        new_expected_values$y[i] <- self$expected_values$y[i] - current_proj_y_right + new_proj_y_right
      }
      new_x_expected <- t(as.matrix(new_expected_values[,1]))
      new_y_expected <- t(as.matrix(new_expected_values[,2]))
      sigma_x <- self$dataTree$param$sigma_x
      sigma_y <- self$dataTree$param$sigma_y
      new_prob_x <- private$get_prob_x(new_x_expected,sigma_x)
      new_prob_y <- private$get_prob_y(new_y_expected,sigma_y)
      new_prob_xy <-new_prob_x + new_prob_y
      new_likelihood <- private$.prob_W + new_prob_v + new_prob_xy
      # PRIOR
      new_prior <- private$get_new_prior(new_val, "root_r")
      # PROPOSAL
      accept <- private$propose(private$.prior, new_prior, private$.likelihood, new_likelihood)
      if (accept) {
        # Updating real values
        self$dataTree$param$root_r <- new_val
        self$dataTree$V$r[root] <- new_val
        private$.prob_r <- new_prob_r
        private$.prob_V <- new_prob_v
        private$.prob_x <- new_prob_x
        private$.prob_y <- new_prob_y
        private$.prob_XY <- new_prob_xy
        private$.likelihood <- new_likelihood
        private$.prior <- new_prior
        private$.posterior <- private$.prior + private$.likelihood
        # MCMC OBJECTS: expected_values, branches
        private$.expected_values <- new_expected_values
        private$.branch_probs$prob_r[row_left] <- new_branch_prob_left
        private$.branch_probs$prob_r[row_right] <- new_branch_prob_right
        private$.branch_probs$start_r[row_left] <- new_val
        private$.branch_probs$start_r[row_right] <- new_val
        private$.branch_probs$proj_x[row_left] <- new_proj_x_left
        private$.branch_probs$proj_x[row_right] <- new_proj_x_right
        private$.branch_probs$proj_y[row_left] <- new_proj_y_left
        private$.branch_probs$proj_y[row_right] <- new_proj_y_right
      }
    }

    private$tune(accept)

  },

  #' @description Performs a proposal on root_s
  propose_root_s = function() {

    # PARAMETER UPDATES: root_s
    # Getting current value
    current_val = self$dataTree$param$root_s
    # Suggesting a new value
    hyperparam = private$.acceptances$root_s$hyperparam
    new_val <- current_val + runif(1,-1*hyperparam,hyperparam)

    # PROBABILTIY UPDATES
    if (abs(new_val) >= 100) {accept <- FALSE} else {
      # W: None
      # V: prob_s, prob_v
      root <- self$dataTree$tree$n_tips + 1
      row_left <- which(self$branch_probs$start_node == root & self$branch_probs$child == "left")
      row_right <- which(self$branch_probs$start_node == root & self$branch_probs$child == "right")
      length_left <- self$branch_probs$length[row_left]
      length_right <- self$branch_probs$length[row_right]
      end_left <- self$branch_probs$end_s[row_left]
      end_right <- self$branch_probs$end_s[row_right]
      current_branch_prob_left <- self$branch_probs$prob_s[row_left]
      current_branch_prob_right <- self$branch_probs$prob_s[row_right]
      sigma_s <- self$dataTree$param$sigma_s
      new_branch_prob_left <- private$get_branch_prob_rs(new_val,end_left,length_left,sigma_s)
      new_branch_prob_right <- private$get_branch_prob_rs(new_val,end_right,length_right,sigma_s)
      new_prob_s <- private$.prob_s - current_branch_prob_left - current_branch_prob_right + new_branch_prob_left + new_branch_prob_right
      new_prob_v <- private$.prob_a + private$.prob_r + new_prob_s
      # XY: prob_x, prob_y, prob_xy
      current_proj_x_left <- self$branch_probs$proj_x[row_left]
      current_proj_x_right <- self$branch_probs$proj_x[row_right]
      current_proj_y_left <- self$branch_probs$proj_y[row_left]
      current_proj_y_right <- self$branch_probs$proj_y[row_right]
      d <- self$dataTree$W$d[1]
      m <- self$dataTree$W$m[1]
      cval <- self$dataTree$W$cval[1]
      hval <- self$dataTree$W$hval[1]
      r <- self$dataTree$V$r[root]
      a <- self$dataTree$V$a[root]
      z <- self$dataTree$param$z
      new_proj_x_left <- transform_node(char="x", daughter="left", d=d, m=m, c=cval, h=hval, x=0, r=r, s=new_val, a=a, z=z)
      new_proj_x_right <- transform_node(char="x", daughter="right", d=d, m=m, c=cval, h=hval, x=0, r=r, s=new_val, a=a, z=z)
      new_proj_y_left <- transform_node(char="y", daughter="left", d=d, m=m, c=cval, h=hval, y=0, r=r, s=new_val, a=a, z=z)
      new_proj_y_right <- transform_node(char="y", daughter="right", d=d, m=m, c=cval, h=hval, y=0, r=r, s=new_val, a=a, z=z)
      tips_left <- which(self$dataTree$tree$tip_descendants[self$branch_probs$end_node[row_left],]==1)
      tips_right <- which(self$dataTree$tree$tip_descendants[self$branch_probs$end_node[row_right],]==1)
      new_expected_values <- self$expected_values
      for (i in tips_left) {
        new_expected_values$x[i] <- self$expected_values$x[i] - current_proj_x_left + new_proj_x_left
        new_expected_values$y[i] <- self$expected_values$y[i] - current_proj_y_left + new_proj_y_left
      }
      for (i in tips_right) {
        new_expected_values$x[i] <- self$expected_values$x[i] - current_proj_x_right + new_proj_x_right
        new_expected_values$y[i] <- self$expected_values$y[i] - current_proj_y_right + new_proj_y_right
      }
      new_x_expected <- t(as.matrix(new_expected_values[,1]))
      new_y_expected <- t(as.matrix(new_expected_values[,2]))
      sigma_x <- self$dataTree$param$sigma_x
      sigma_y <- self$dataTree$param$sigma_y
      new_prob_x <- private$get_prob_x(new_x_expected,sigma_x)
      new_prob_y <- private$get_prob_y(new_y_expected,sigma_y)
      new_prob_xy <-new_prob_x + new_prob_y
      new_likelihood <- private$.prob_W + new_prob_v + new_prob_xy
      # PRIOR
      new_prior <- private$get_new_prior(new_val, "root_s")
      # PROPOSAL
      accept <- private$propose(private$.prior, new_prior, private$.likelihood, new_likelihood)
      if (accept) {
        # Updating real values
        self$dataTree$param$root_s <- new_val
        self$dataTree$V$s[root] <- new_val
        private$.prob_s <- new_prob_s
        private$.prob_V <- new_prob_v
        private$.prob_x <- new_prob_x
        private$.prob_y <- new_prob_y
        private$.prob_XY <- new_prob_xy
        private$.likelihood <- new_likelihood
        private$.prior <- new_prior
        private$.posterior <- private$.prior + private$.likelihood
        # MCMC OBJECTS: expected_values, branches
        private$.expected_values <- new_expected_values
        private$.branch_probs$prob_s[row_left] <- new_branch_prob_left
        private$.branch_probs$prob_s[row_right] <- new_branch_prob_right
        private$.branch_probs$start_s[row_left] <- new_val
        private$.branch_probs$start_s[row_right] <- new_val
        private$.branch_probs$proj_x[row_left] <- new_proj_x_left
        private$.branch_probs$proj_x[row_right] <- new_proj_x_right
        private$.branch_probs$proj_y[row_left] <- new_proj_y_left
        private$.branch_probs$proj_y[row_right] <- new_proj_y_right
      }
    }

    private$tune(accept)

  },

  #' @description Performs a proposal on root_a
  propose_root_a = function() {

    # PARAMETER UPDATES: root_r
    # Getting current value
    current_val = self$dataTree$param$root_a
    # Suggesting a new value
    hyperparam = private$.acceptances$root_a$hyperparam
    new_val <- current_val + runif(1,-1*hyperparam,hyperparam)

    # PROBABILTIY UPDATES
    if (abs(new_val) >= 50) {accept <- FALSE} else {
      # W: None
      # V: prob_a, prob_v
      root <- self$dataTree$tree$n_tips + 1
      row_left <- which(self$branch_probs$start_node == root & self$branch_probs$child == "left")
      row_right <- which(self$branch_probs$start_node == root & self$branch_probs$child == "right")
      length_left <- self$branch_probs$length[row_left]
      length_right <- self$branch_probs$length[row_right]
      end_left <- self$branch_probs$end_a[row_left]
      end_right <- self$branch_probs$end_a[row_right]
      current_branch_prob_left <- self$branch_probs$prob_a[row_left]
      current_branch_prob_right <- self$branch_probs$prob_a[row_right]
      d <- self$dataTree$W$d[1]
      m <- self$dataTree$W$m[1]
      cval <- self$dataTree$W$cval[1]
      alpha <- self$dataTree$param$alpha
      new_start_left <- transform_node(char="a", daughter="left", d=d, m=m, c=cval, a=new_val, alpha=alpha)
      new_start_right <- transform_node(char="a", daughter="right", d=d, m=m, c=cval, a=new_val, alpha=alpha)
      sigma_a <- self$dataTree$param$sigma_a
      mu <- self$dataTree$param$mu
      kappa <- self$dataTree$param$kappa
      new_branch_prob_left <- private$get_branch_prob_a(new_start_left,end_left,length_left,sigma_a,mu,kappa)
      new_branch_prob_right <- private$get_branch_prob_a(new_start_right,end_right,length_right,sigma_a,mu,kappa)
      new_prob_a <- private$.prob_a - current_branch_prob_left - current_branch_prob_right + new_branch_prob_left + new_branch_prob_right
      new_prob_v <- private$.prob_r + private$.prob_s + new_prob_a
      # XY: prob_x, prob_y, prob_xy
      current_proj_x_left <- self$branch_probs$proj_x[row_left]
      current_proj_x_right <- self$branch_probs$proj_x[row_right]
      current_proj_y_left <- self$branch_probs$proj_y[row_left]
      current_proj_y_right <- self$branch_probs$proj_y[row_right]
      d <- self$dataTree$W$d[1]
      m <- self$dataTree$W$m[1]
      cval <- self$dataTree$W$cval[1]
      hval <- self$dataTree$W$hval[1]
      s <- self$dataTree$V$s[root]
      r <- self$dataTree$V$r[root]
      z <- self$dataTree$param$z
      new_proj_x_left <- transform_node(char="x", daughter="left", d=d, m=m, c=cval, h=hval, x=0, r=r, s=s, a=new_val, z=z)
      new_proj_x_right <- transform_node(char="x", daughter="right", d=d, m=m, c=cval, h=hval, x=0, r=r, s=s, a=new_val, z=z)
      new_proj_y_left <- transform_node(char="y", daughter="left", d=d, m=m, c=cval, h=hval, y=0, r=r, s=s, a=new_val, z=z)
      new_proj_y_right <- transform_node(char="y", daughter="right", d=d, m=m, c=cval, h=hval, y=0, r=r, s=s, a=new_val, z=z)
      tips_left <- which(self$dataTree$tree$tip_descendants[self$branch_probs$end_node[row_left],]==1)
      tips_right <- which(self$dataTree$tree$tip_descendants[self$branch_probs$end_node[row_right],]==1)
      new_expected_values <- self$expected_values
      for (i in tips_left) {
        new_expected_values$x[i] <- self$expected_values$x[i] - current_proj_x_left + new_proj_x_left
        new_expected_values$y[i] <- self$expected_values$y[i] - current_proj_y_left + new_proj_y_left
      }
      for (i in tips_right) {
        new_expected_values$x[i] <- self$expected_values$x[i] - current_proj_x_right + new_proj_x_right
        new_expected_values$y[i] <- self$expected_values$y[i] - current_proj_y_right + new_proj_y_right
      }
      new_x_expected <- t(as.matrix(new_expected_values[,1]))
      new_y_expected <- t(as.matrix(new_expected_values[,2]))
      sigma_x <- self$dataTree$param$sigma_x
      sigma_y <- self$dataTree$param$sigma_y
      new_prob_x <- private$get_prob_x(new_x_expected,sigma_x)
      new_prob_y <- private$get_prob_y(new_y_expected,sigma_y)
      new_prob_xy <-new_prob_x + new_prob_y
      new_likelihood <- private$.prob_W + new_prob_v + new_prob_xy
      # PRIOR
      new_prior <- private$get_new_prior(new_val, "root_a")
      # PROPOSAL
      accept <- private$propose(private$.prior, new_prior, private$.likelihood, new_likelihood)
      if (accept) {
        # Updating real values
        self$dataTree$param$root_a <- new_val
        self$dataTree$V$a[root] <- new_val
        private$.prob_a <- new_prob_a
        private$.prob_V <- new_prob_v
        private$.prob_x <- new_prob_x
        private$.prob_y <- new_prob_y
        private$.prob_XY <- new_prob_xy
        private$.likelihood <- new_likelihood
        private$.prior <- new_prior
        private$.posterior <- private$.prior + private$.likelihood
        # MCMC OBJECTS: expected_values, branches
        private$.expected_values <- new_expected_values
        private$.branch_probs$prob_a[row_left] <- new_branch_prob_left
        private$.branch_probs$prob_a[row_right] <- new_branch_prob_right
        private$.branch_probs$start_a[row_left] <- new_start_left
        private$.branch_probs$start_a[row_right] <- new_start_right
        private$.branch_probs$proj_x[row_left] <- new_proj_x_left
        private$.branch_probs$proj_x[row_right] <- new_proj_x_right
        private$.branch_probs$proj_y[row_left] <- new_proj_y_left
        private$.branch_probs$proj_y[row_right] <- new_proj_y_right
      }
    }

    private$tune(accept)

  },

  #' @description Performs a proposal on V_r and V_s (the values of r and s) at one tip chosen at random -- this proposal suggests swapping to the other (r,s) pair that defines the same ellipse
  propose_tip = function() {

    # PARAMETER UPDATES: None

    # PROBABILTIY UPDATES
    # W: None
    # V: prob_r, prob_s, prob_v
    tip <- sample(1:self$dataTree$tree$n_tips,size=1)
    row <- which(self$branch_probs$end_node == tip)
    current_r <- self$branch_probs$end_r[row]
    current_s <- self$branch_probs$end_s[row]
    new_r <- current_r * -1
    new_s <- current_s * -1
    start_r <- self$branch_probs$start_r[row]
    start_s <- self$branch_probs$start_s[row]
    length <- self$branch_probs$length[row]
    current_branch_prob_r <- self$branch_probs$prob_r[row]
    current_branch_prob_s <- self$branch_probs$prob_s[row]
    sigma_r <- self$dataTree$param$sigma_r
    sigma_s <- self$dataTree$param$sigma_s
    new_branch_prob_r <- private$get_branch_prob_rs(start_r,new_r,length,sigma_r)
    new_branch_prob_s <- private$get_branch_prob_rs(start_s,new_s,length,sigma_s)
    new_prob_r <- private$.prob_r - current_branch_prob_r + new_branch_prob_r
    new_prob_s <- private$.prob_s - current_branch_prob_s + new_branch_prob_s
    new_prob_v <- private$.prob_a + new_prob_r + new_prob_s
    new_likelihood <- private$.prob_W + new_prob_v + private$.prob_XY
    # XY: None
    # PRIOR: None
    new_prior <- private$.prior
    # PROPOSAL
    accept <- private$propose(private$.prior, new_prior, private$.likelihood, new_likelihood)
    if (accept) {
      # Updating real values
      self$dataTree$V$r[tip] <- new_r
      self$dataTree$V$s[tip] <- new_s
      private$.prob_r <- new_prob_r
      private$.prob_s <- new_prob_s
      private$.prob_V <- new_prob_v
      private$.likelihood <- new_likelihood
      private$.posterior <- private$.prior + private$.likelihood
      # MCMC OBJECTS: branches
      private$.branch_probs$prob_r[row] <- new_branch_prob_r
      private$.branch_probs$prob_s[row] <- new_branch_prob_s
      private$.branch_probs$end_r[row] <- new_r
      private$.branch_probs$end_s[row] <- new_s
    }

    private$tune(accept)

  },

  #' @description Performs a proposal on V_r (the value of r) at one node chosen at random
  propose_v_r = function() {

    node_list <- c((self$dataTree$tree$n_tips+2):self$dataTree$tree$n_nodes)
    target_node <- sample(node_list, 1)
    node_order <- private$get_local(target_node,category="V")
    for (node in node_order) {

      # PARAMETER UPDATES: None

      # PROBABILTIY UPDATES
      # W: None
      # V: prob_r, prob_v
      row_left <- which(self$branch_probs$start_node == node & self$branch_probs$child == "left")
      row_right <- which(self$branch_probs$start_node == node & self$branch_probs$child == "right")
      row_parent <- which(self$branch_probs$end_node == node)
      current_val <- self$dataTree$V$r[node]
      hyperparam <- private$.acceptances$V_r$hyperparam
      new_val <- current_val + runif(1, -1*hyperparam, hyperparam)
      if (abs(new_val) >= 100) {accept <- FALSE} else {
        length_left <- self$branch_probs$length[row_left]
        length_right <- self$branch_probs$length[row_right]
        length_parent <- self$branch_probs$length[row_parent]
        end_left <- self$branch_probs$end_r[row_left]
        end_right <- self$branch_probs$end_r[row_right]
        start_parent <- self$branch_probs$start_r[row_parent]
        current_branch_prob_left <- self$branch_probs$prob_r[row_left]
        current_branch_prob_right <- self$branch_probs$prob_r[row_right]
        current_branch_prob_parent <- self$branch_probs$prob_r[row_parent]
        sigma_r <- self$dataTree$param$sigma_r
        new_branch_prob_left <- private$get_branch_prob_rs(new_val,end_left,length_left,sigma_r)
        new_branch_prob_right <- private$get_branch_prob_rs(new_val,end_right,length_right,sigma_r)
        new_branch_prob_parent <- private$get_branch_prob_rs(start_parent,new_val,length_parent,sigma_r)
        new_prob_r <- private$.prob_r - current_branch_prob_left - current_branch_prob_right - current_branch_prob_parent + new_branch_prob_left + new_branch_prob_right + new_branch_prob_parent
        new_prob_v <- private$.prob_a + private$.prob_s + new_prob_r
        # XY: prob_x, prob_y, prob_xy
        current_proj_x_left <- self$branch_probs$proj_x[row_left]
        current_proj_x_right <- self$branch_probs$proj_x[row_right]
        current_proj_y_left <- self$branch_probs$proj_y[row_left]
        current_proj_y_right <- self$branch_probs$proj_y[row_right]
        d <- self$dataTree$W$d[node - self$dataTree$tree$n_tips]
        m <- self$dataTree$W$m[node - self$dataTree$tree$n_tips]
        cval <- self$dataTree$W$cval[node - self$dataTree$tree$n_tips]
        hval <- self$dataTree$W$hval[node - self$dataTree$tree$n_tips]
        s <- self$dataTree$V$s[node]
        a <- self$dataTree$V$a[node]
        z <- self$dataTree$param$z
        new_proj_x_left <- transform_node(char="x", daughter="left", d=d, m=m, c=cval, h=hval, x=0, r=new_val, s=s, a=a, z=z)
        new_proj_x_right <- transform_node(char="x", daughter="right", d=d, m=m, c=cval, h=hval, x=0, r=new_val, s=s, a=a, z=z)
        new_proj_y_left <- transform_node(char="y", daughter="left", d=d, m=m, c=cval, h=hval, y=0, r=new_val, s=s, a=a, z=z)
        new_proj_y_right <- transform_node(char="y", daughter="right", d=d, m=m, c=cval, h=hval, y=0, r=new_val, s=s, a=a, z=z)
        tips_left <- which(self$dataTree$tree$tip_descendants[self$branch_probs$end_node[row_left],]==1)
        tips_right <- which(self$dataTree$tree$tip_descendants[self$branch_probs$end_node[row_right],]==1)
        new_expected_values <- self$expected_values
        for (i in tips_left) {
          new_expected_values$x[i] <- self$expected_values$x[i] - current_proj_x_left + new_proj_x_left
          new_expected_values$y[i] <- self$expected_values$y[i] - current_proj_y_left + new_proj_y_left
        }
        for (i in tips_right) {
          new_expected_values$x[i] <- self$expected_values$x[i] - current_proj_x_right + new_proj_x_right
          new_expected_values$y[i] <- self$expected_values$y[i] - current_proj_y_right + new_proj_y_right
        }
        new_x_expected <- t(as.matrix(new_expected_values[,1]))
        new_y_expected <- t(as.matrix(new_expected_values[,2]))
        sigma_x <- self$dataTree$param$sigma_x
        sigma_y <- self$dataTree$param$sigma_y
        new_prob_x <- private$get_prob_x(new_x_expected,sigma_x)
        new_prob_y <- private$get_prob_y(new_y_expected,sigma_y)
        new_prob_xy <- new_prob_x + new_prob_y
        new_likelihood <- private$.prob_W + new_prob_v + new_prob_xy
        # PRIOR: None
        new_prior <- private$.prior
        # PROPOSAL
        accept <- private$propose(private$.prior, new_prior, private$.likelihood, new_likelihood)
        if (accept) {
          # Updating real values
          self$dataTree$V$r[node] <- new_val
          private$.prob_r <- new_prob_r
          private$.prob_V <- new_prob_v
          private$.prob_x <- new_prob_x
          private$.prob_y <- new_prob_y
          private$.prob_XY <- new_prob_xy
          private$.likelihood <- new_likelihood
          private$.posterior <- private$.prior + private$.likelihood
          # MCMC OBJECTS: expected_values, branches
          private$.expected_values <- new_expected_values
          private$.branch_probs$prob_r[row_left] <- new_branch_prob_left
          private$.branch_probs$prob_r[row_right] <- new_branch_prob_right
          private$.branch_probs$prob_r[row_parent] <- new_branch_prob_parent
          private$.branch_probs$start_r[row_left] <- new_val
          private$.branch_probs$start_r[row_right] <- new_val
          private$.branch_probs$end_r[row_parent] <- new_val
          private$.branch_probs$proj_x[row_left] <- new_proj_x_left
          private$.branch_probs$proj_x[row_right] <- new_proj_x_right
          private$.branch_probs$proj_y[row_left] <- new_proj_y_left
          private$.branch_probs$proj_y[row_right] <- new_proj_y_right
        }
      }

      private$tune(accept)

    }
  },

  #' @description Performs a proposal on V_s (the value of s) at one node chosen at random
  propose_v_s = function() {

    node_list <- c((self$dataTree$tree$n_tips+2):self$dataTree$tree$n_nodes)
    target_node <- sample(node_list, 1)
    node_order <- private$get_local(target_node,category="V")
    for (node in node_order) {

      # PARAMETER UPDATES: None

      # PROBABILTIY UPDATES
      # W: None
      # V: prob_s, prob_v
      row_left <- which(self$branch_probs$start_node == node & self$branch_probs$child == "left")
      row_right <- which(self$branch_probs$start_node == node & self$branch_probs$child == "right")
      row_parent <- which(self$branch_probs$end_node == node)
      current_val <- self$dataTree$V$s[node]
      hyperparam <- private$.acceptances$V_s$hyperparam
      new_val <- current_val + runif(1, -1*hyperparam, hyperparam)
      if (abs(new_val) >= 100) {accept <- FALSE} else {
        length_left <- self$branch_probs$length[row_left]
        length_right <- self$branch_probs$length[row_right]
        length_parent <- self$branch_probs$length[row_parent]
        end_left <- self$branch_probs$end_s[row_left]
        end_right <- self$branch_probs$end_s[row_right]
        start_parent <- self$branch_probs$start_s[row_parent]
        current_branch_prob_left <- self$branch_probs$prob_s[row_left]
        current_branch_prob_right <- self$branch_probs$prob_s[row_right]
        current_branch_prob_parent <- self$branch_probs$prob_s[row_parent]
        sigma_s <- self$dataTree$param$sigma_s
        new_branch_prob_left <- private$get_branch_prob_rs(new_val,end_left,length_left,sigma_s)
        new_branch_prob_right <- private$get_branch_prob_rs(new_val,end_right,length_right,sigma_s)
        new_branch_prob_parent <- private$get_branch_prob_rs(start_parent,new_val,length_parent,sigma_s)
        new_prob_s <- private$.prob_s - current_branch_prob_left - current_branch_prob_right - current_branch_prob_parent + new_branch_prob_left + new_branch_prob_right + new_branch_prob_parent
        new_prob_v <- private$.prob_a + private$.prob_r + new_prob_s
        # XY: prob_x, prob_y, prob_xy
        current_proj_x_left <- self$branch_probs$proj_x[row_left]
        current_proj_x_right <- self$branch_probs$proj_x[row_right]
        current_proj_y_left <- self$branch_probs$proj_y[row_left]
        current_proj_y_right <- self$branch_probs$proj_y[row_right]
        d <- self$dataTree$W$d[node - self$dataTree$tree$n_tips]
        m <- self$dataTree$W$m[node - self$dataTree$tree$n_tips]
        cval <- self$dataTree$W$cval[node - self$dataTree$tree$n_tips]
        hval <- self$dataTree$W$hval[node - self$dataTree$tree$n_tips]
        r <- self$dataTree$V$r[node]
        a <- self$dataTree$V$a[node]
        z <- self$dataTree$param$z
        new_proj_x_left <- transform_node(char="x", daughter="left", d=d, m=m, c=cval, h=hval, x=0, r=r, s=new_val, a=a, z=z)
        new_proj_x_right <- transform_node(char="x", daughter="right", d=d, m=m, c=cval, h=hval, x=0, r=r, s=new_val, a=a, z=z)
        new_proj_y_left <- transform_node(char="y", daughter="left", d=d, m=m, c=cval, h=hval, y=0, r=r, s=new_val, a=a, z=z)
        new_proj_y_right <- transform_node(char="y", daughter="right", d=d, m=m, c=cval, h=hval, y=0, r=r, s=new_val, a=a, z=z)
        tips_left <- which(self$dataTree$tree$tip_descendants[self$branch_probs$end_node[row_left],]==1)
        tips_right <- which(self$dataTree$tree$tip_descendants[self$branch_probs$end_node[row_right],]==1)
        new_expected_values <- self$expected_values
        for (i in tips_left) {
          new_expected_values$x[i] <- self$expected_values$x[i] - current_proj_x_left + new_proj_x_left
          new_expected_values$y[i] <- self$expected_values$y[i] - current_proj_y_left + new_proj_y_left
        }
        for (i in tips_right) {
          new_expected_values$x[i] <- self$expected_values$x[i] - current_proj_x_right + new_proj_x_right
          new_expected_values$y[i] <- self$expected_values$y[i] - current_proj_y_right + new_proj_y_right
        }
        new_x_expected <- t(as.matrix(new_expected_values[,1]))
        new_y_expected <- t(as.matrix(new_expected_values[,2]))
        sigma_x <- self$dataTree$param$sigma_x
        sigma_y <- self$dataTree$param$sigma_y
        new_prob_x <- private$get_prob_x(new_x_expected,sigma_x)
        new_prob_y <- private$get_prob_y(new_y_expected,sigma_y)
        new_prob_xy <- new_prob_x + new_prob_y
        new_likelihood <- private$.prob_W + new_prob_v + new_prob_xy
        # PRIOR: None
        new_prior <- private$.prior
        # PROPOSAL
        accept <- private$propose(private$.prior, new_prior, private$.likelihood, new_likelihood)
        if (accept) {
          # Updating real values
          self$dataTree$V$s[node] <- new_val
          private$.prob_s <- new_prob_s
          private$.prob_V <- new_prob_v
          private$.prob_x <- new_prob_x
          private$.prob_y <- new_prob_y
          private$.prob_XY <- new_prob_xy
          private$.likelihood <- new_likelihood
          private$.posterior <- private$.prior + private$.likelihood
          # MCMC OBJECTS: expected_values, branches
          private$.expected_values <- new_expected_values
          private$.branch_probs$prob_s[row_left] <- new_branch_prob_left
          private$.branch_probs$prob_s[row_right] <- new_branch_prob_right
          private$.branch_probs$prob_s[row_parent] <- new_branch_prob_parent
          private$.branch_probs$start_s[row_left] <- new_val
          private$.branch_probs$start_s[row_right] <- new_val
          private$.branch_probs$end_s[row_parent] <- new_val
          private$.branch_probs$proj_x[row_left] <- new_proj_x_left
          private$.branch_probs$proj_x[row_right] <- new_proj_x_right
          private$.branch_probs$proj_y[row_left] <- new_proj_y_left
          private$.branch_probs$proj_y[row_right] <- new_proj_y_right
        }
      }

      private$tune(accept)

    }
  },

  #' @description Performs a proposal on V_a (the value of a) at one node chosen at random
  propose_v_a = function() {

    node_list <- c((self$dataTree$tree$n_tips+2):self$dataTree$tree$n_nodes)
    target_node <- sample(node_list, 1)
    node_order <- private$get_local(target_node,category="V")
    for (node in node_order) {

      # PARAMETER UPDATES: None

      # PROBABILTIY UPDATES
      # W: None
      # V: prob_a, prob_v
      row_left <- which(self$branch_probs$start_node == node & self$branch_probs$child == "left")
      row_right <- which(self$branch_probs$start_node == node & self$branch_probs$child == "right")
      row_parent <- which(self$branch_probs$end_node == node)
      current_val <- self$dataTree$V$a[node]
      hyperparam <- private$.acceptances$V_a$hyperparam
      new_val <- current_val + runif(1, -1*hyperparam, hyperparam)
      if (abs(new_val) >= 50) {accept <- FALSE} else {
        length_left <- self$branch_probs$length[row_left]
        length_right <- self$branch_probs$length[row_right]
        length_parent <- self$branch_probs$length[row_parent]
        end_left <- self$branch_probs$end_a[row_left]
        end_right <- self$branch_probs$end_a[row_right]
        start_parent <- self$branch_probs$start_a[row_parent]
        current_branch_prob_left <- self$branch_probs$prob_a[row_left]
        current_branch_prob_right <- self$branch_probs$prob_a[row_right]
        current_branch_prob_parent <- self$branch_probs$prob_a[row_parent]
        d <- self$dataTree$W$d[node - self$dataTree$tree$n_tips]
	m <- self$dataTree$W$m[node - self$dataTree$tree$n_tips]
        cval <- self$dataTree$W$cval[node - self$dataTree$tree$n_tips]
        alpha <- self$dataTree$param$alpha
        new_start_left <- transform_node(char="a", daughter="left", d=d, m=m, c=cval, a=new_val, alpha=alpha)
        new_start_right <- transform_node(char="a", daughter="right", d=d, m=m, c=cval, a=new_val, alpha=alpha)
        sigma_a <- self$dataTree$param$sigma_a
        mu <- self$dataTree$param$mu
        kappa <- self$dataTree$param$kappa
        new_branch_prob_left <- private$get_branch_prob_a(new_start_left,end_left,length_left,sigma_a,mu,kappa)
        new_branch_prob_right <- private$get_branch_prob_a(new_start_right,end_right,length_right,sigma_a,mu,kappa)
        new_branch_prob_parent <- private$get_branch_prob_a(start_parent,new_val,length_parent,sigma_a,mu,kappa)
        new_prob_a <- private$.prob_a - current_branch_prob_left - current_branch_prob_right - current_branch_prob_parent + new_branch_prob_left + new_branch_prob_right + new_branch_prob_parent
        new_prob_v <- private$.prob_r + private$.prob_s + new_prob_a
        # XY: prob_x, prob_y, prob_xy
        current_proj_x_left <- self$branch_probs$proj_x[row_left]
        current_proj_x_right <- self$branch_probs$proj_x[row_right]
        current_proj_y_left <- self$branch_probs$proj_y[row_left]
        current_proj_y_right <- self$branch_probs$proj_y[row_right]
        d <- self$dataTree$W$d[node - self$dataTree$tree$n_tips]
        m <- self$dataTree$W$m[node - self$dataTree$tree$n_tips]
        cval <- self$dataTree$W$cval[node - self$dataTree$tree$n_tips]
        hval <- self$dataTree$W$hval[node - self$dataTree$tree$n_tips]
        s <- self$dataTree$V$s[node]
        r <- self$dataTree$V$r[node]
        z <- self$dataTree$param$z
        new_proj_x_left <- transform_node(char="x", daughter="left", d=d, m=m, c=cval, h=hval, x=0, r=r, s=s, a=new_val, z=z)
        new_proj_x_right <- transform_node(char="x", daughter="right", d=d, m=m, c=cval, h=hval, x=0, r=r, s=s, a=new_val, z=z)
        new_proj_y_left <- transform_node(char="y", daughter="left", d=d, m=m, c=cval, h=hval, y=0, r=r, s=s, a=new_val, z=z)
        new_proj_y_right <- transform_node(char="y", daughter="right", d=d, m=m, c=cval, h=hval, y=0, r=r, s=s, a=new_val, z=z)
        tips_left <- which(self$dataTree$tree$tip_descendants[self$branch_probs$end_node[row_left],]==1)
        tips_right <- which(self$dataTree$tree$tip_descendants[self$branch_probs$end_node[row_right],]==1)
        new_expected_values <- self$expected_values
        for (i in tips_left) {
          new_expected_values$x[i] <- self$expected_values$x[i] - current_proj_x_left + new_proj_x_left
          new_expected_values$y[i] <- self$expected_values$y[i] - current_proj_y_left + new_proj_y_left
        }
        for (i in tips_right) {
          new_expected_values$x[i] <- self$expected_values$x[i] - current_proj_x_right + new_proj_x_right
          new_expected_values$y[i] <- self$expected_values$y[i] - current_proj_y_right + new_proj_y_right
        }
        new_x_expected <- t(as.matrix(new_expected_values[,1]))
        new_y_expected <- t(as.matrix(new_expected_values[,2]))
        sigma_x <- self$dataTree$param$sigma_x
        sigma_y <- self$dataTree$param$sigma_y
        new_prob_x <- private$get_prob_x(new_x_expected,sigma_x)
        new_prob_y <- private$get_prob_y(new_y_expected,sigma_y)
        new_prob_xy <- new_prob_x + new_prob_y
        new_likelihood <- private$.prob_W + new_prob_v + new_prob_xy
        # PRIOR: None
        new_prior <- private$.prior
        # PROPOSAL
        accept <- private$propose(private$.prior, new_prior, private$.likelihood, new_likelihood)
        if (accept) {
          # Updating real values
          self$dataTree$V$a[node] <- new_val
          private$.prob_a <- new_prob_a
          private$.prob_V <- new_prob_v
          private$.prob_x <- new_prob_x
          private$.prob_y <- new_prob_y
          private$.prob_XY <- new_prob_xy
          private$.likelihood <- new_likelihood
          private$.posterior <- private$.prior + private$.likelihood
          # MCMC OBJECTS: expected_values, branches
          private$.expected_values <- new_expected_values
          private$.branch_probs$prob_a[row_left] <- new_branch_prob_left
          private$.branch_probs$prob_a[row_right] <- new_branch_prob_right
          private$.branch_probs$prob_a[row_parent] <- new_branch_prob_parent
          private$.branch_probs$start_a[row_left] <- new_start_left
          private$.branch_probs$start_a[row_right] <- new_start_right
          private$.branch_probs$end_a[row_parent] <- new_val
          private$.branch_probs$proj_x[row_left] <- new_proj_x_left
          private$.branch_probs$proj_x[row_right] <- new_proj_x_right
          private$.branch_probs$proj_y[row_left] <- new_proj_y_left
          private$.branch_probs$proj_y[row_right] <- new_proj_y_right
        }
      }

      private$tune(accept)

    }
  },

  #' @description Performs a proposal on W_d (the daughter configuration) at one node chosen at random
  propose_w_d = function() {

    node_list <- c((self$dataTree$tree$n_tips+1):self$dataTree$tree$n_nodes)
    target_node <- sample(node_list, 1)
    node_order <- private$get_local(target_node,category="W")
    for (node in node_order) {

      # PARAMETER UPDATES: None

      # PROBABILTIY UPDATES
      # W: prob_w
      row <- node - self$dataTree$tree$n_tips
      current_val <- self$dataTree$W$d[row]
      if (current_val == 0) {new_val <- 1} else {new_val <- 0}
      new_prob_w <- private$.prob_W
      # V: prob_a, prob_v
      row_left <- which(self$branch_probs$start_node == node & self$branch_probs$child == "left")
      row_right <- which(self$branch_probs$start_node == node & self$branch_probs$child == "right")
      a <- self$dataTree$V$a[node]
      length_left <- self$branch_probs$length[row_left]
      length_right <- self$branch_probs$length[row_right]
      end_left <- self$branch_probs$end_a[row_left]
      end_right <- self$branch_probs$end_a[row_right]
      current_branch_prob_left <- self$branch_probs$prob_a[row_left]
      current_branch_prob_right <- self$branch_probs$prob_a[row_right]
      m <- self$dataTree$W$m[row]
      cval <- self$dataTree$W$cval[row]
      alpha <- self$dataTree$param$alpha
      new_start_left <- transform_node(char="a", daughter="left", d=new_val, m=m, c=cval, a=a, alpha=alpha)
      new_start_right <- transform_node(char="a", daughter="right", d=new_val, m=m, c=cval, a=a, alpha=alpha)
      sigma_a <- self$dataTree$param$sigma_a
      mu <- self$dataTree$param$mu
      kappa <- self$dataTree$param$kappa
      new_branch_prob_left <- private$get_branch_prob_a(new_start_left,end_left,length_left,sigma_a,mu,kappa)
      new_branch_prob_right <- private$get_branch_prob_a(new_start_right,end_right,length_right,sigma_a,mu,kappa)
      new_prob_a <- private$.prob_a - current_branch_prob_left - current_branch_prob_right + new_branch_prob_left + new_branch_prob_right
      new_prob_v <- private$.prob_r + private$.prob_s + new_prob_a
      # XY: prob_x, prob_y, prob_xy
      current_proj_x_left <- self$branch_probs$proj_x[row_left]
      current_proj_x_right <- self$branch_probs$proj_x[row_right]
      current_proj_y_left <- self$branch_probs$proj_y[row_left]
      current_proj_y_right <- self$branch_probs$proj_y[row_right]
      m <- self$dataTree$W$m[row]
      cval <- self$dataTree$W$cval[row]
      hval <- self$dataTree$W$hval[row]
      s <- self$dataTree$V$s[node]
      r <- self$dataTree$V$r[node]
      a <- self$dataTree$V$a[node]
      z <- self$dataTree$param$z
      new_proj_x_left <- transform_node(char="x", daughter="left", d=new_val, m=m, c=cval, h=hval, x=0, r=r, s=s, a=a, z=z)
      new_proj_x_right <- transform_node(char="x", daughter="right", d=new_val, m=m, c=cval, h=hval, x=0, r=r, s=s, a=a, z=z)
      new_proj_y_left <- transform_node(char="y", daughter="left", d=new_val, m=m, c=cval, h=hval, y=0, r=r, s=s, a=a, z=z)
      new_proj_y_right <- transform_node(char="y", daughter="right", d=new_val, m=m, c=cval, h=hval, y=0, r=r, s=s, a=a, z=z)
      tips_left <- which(self$dataTree$tree$tip_descendants[self$branch_probs$end_node[row_left],]==1)
      tips_right <- which(self$dataTree$tree$tip_descendants[self$branch_probs$end_node[row_right],]==1)
      new_expected_values <- self$expected_values
      for (i in tips_left) {
        new_expected_values$x[i] <- self$expected_values$x[i] - current_proj_x_left + new_proj_x_left
        new_expected_values$y[i] <- self$expected_values$y[i] - current_proj_y_left + new_proj_y_left
      }
      for (i in tips_right) {
        new_expected_values$x[i] <- self$expected_values$x[i] - current_proj_x_right + new_proj_x_right
        new_expected_values$y[i] <- self$expected_values$y[i] - current_proj_y_right + new_proj_y_right
      }
      new_x_expected <- t(as.matrix(new_expected_values[,1]))
      new_y_expected <- t(as.matrix(new_expected_values[,2]))
      sigma_x <- self$dataTree$param$sigma_x
      sigma_y <- self$dataTree$param$sigma_y
      new_prob_x <- private$get_prob_x(new_x_expected,sigma_x)
      new_prob_y <- private$get_prob_y(new_y_expected,sigma_y)
      new_prob_xy <- new_prob_x + new_prob_y
      new_likelihood <- new_prob_w + new_prob_v + new_prob_xy
      # PRIOR: None
      new_prior <- private$.prior
      # PROPOSAL
      accept <- private$propose(private$.prior, new_prior, private$.likelihood, new_likelihood)
      if (accept) {
        # Updating real values
        self$dataTree$W$d[row] <- new_val
        private$.prob_W <- new_prob_w
        private$.prob_a <- new_prob_a
        private$.prob_V <- new_prob_v
        private$.prob_x <- new_prob_x
        private$.prob_y <- new_prob_y
        private$.prob_XY <- new_prob_xy
        private$.likelihood <- new_likelihood
        private$.prior <- new_prior
        private$.posterior <- private$.prior + private$.likelihood
        # MCMC OBJECTS: expected_values, branches
        private$.expected_values <- new_expected_values
        private$.branch_probs$prob_a[row_left] <- new_branch_prob_left
        private$.branch_probs$prob_a[row_right] <- new_branch_prob_right
        private$.branch_probs$start_a[row_left] <- new_start_left
        private$.branch_probs$start_a[row_right] <- new_start_right
        private$.branch_probs$proj_x[row_left] <- new_proj_x_left
        private$.branch_probs$proj_x[row_right] <- new_proj_x_right
        private$.branch_probs$proj_y[row_left] <- new_proj_y_left
        private$.branch_probs$proj_y[row_right] <- new_proj_y_right
      }

      private$tune(accept)

    }
  },

  #' @description Performs a proposal on W_m (the cladogenetic mode) at one node chosen at random
  propose_w_m = function() {

    node_list <- c((self$dataTree$tree$n_tips+1):self$dataTree$tree$n_nodes)
    target_node <- sample(node_list, 1)
    node_order <- private$get_local(target_node,category="W")
    for (node in node_order) {

      # PARAMETER UPDATES: None

      # PROBABILTIY UPDATES
      # W: prob_w
      row <- node - self$dataTree$tree$n_tips
      current_val <- self$dataTree$W$m[row]
      if (current_val == 0) {new_val <- 1} else {new_val <- 0}
      current_node_prob_w <- log(self$dataTree$param$rho_m[current_val+1])
      new_node_prob_w <- log(self$dataTree$param$rho_m[new_val+1])
      new_prob_w <- private$.prob_W - current_node_prob_w + new_node_prob_w
      # V: prob_a, prob_v
      row_left <- which(self$branch_probs$start_node == node & self$branch_probs$child == "left")
      row_right <- which(self$branch_probs$start_node == node & self$branch_probs$child == "right")
      a <- self$dataTree$V$a[node]
      length_left <- self$branch_probs$length[row_left]
      length_right <- self$branch_probs$length[row_right]
      end_left <- self$branch_probs$end_a[row_left]
      end_right <- self$branch_probs$end_a[row_right]
      current_branch_prob_left <- self$branch_probs$prob_a[row_left]
      current_branch_prob_right <- self$branch_probs$prob_a[row_right]
      d <- self$dataTree$W$d[row]
      cval <- self$dataTree$W$cval[row]
      alpha <- self$dataTree$param$alpha
      new_start_left <- transform_node(char="a", daughter="left", d=d, m=new_val, c=cval, a=a, alpha=alpha)
      new_start_right <- transform_node(char="a", daughter="right", d=d, m=new_val, c=cval, a=a, alpha=alpha)
      sigma_a <- self$dataTree$param$sigma_a
      mu <- self$dataTree$param$mu
      kappa <- self$dataTree$param$kappa
      new_branch_prob_left <- private$get_branch_prob_a(new_start_left,end_left,length_left,sigma_a,mu,kappa)
      new_branch_prob_right <- private$get_branch_prob_a(new_start_right,end_right,length_right,sigma_a,mu,kappa)
      new_prob_a <- private$.prob_a - current_branch_prob_left - current_branch_prob_right + new_branch_prob_left + new_branch_prob_right
      new_prob_v <- private$.prob_r + private$.prob_s + new_prob_a
      # XY: prob_x, prob_y, prob_xy
      current_proj_x_left <- self$branch_probs$proj_x[row_left]
      current_proj_x_right <- self$branch_probs$proj_x[row_right]
      current_proj_y_left <- self$branch_probs$proj_y[row_left]
      current_proj_y_right <- self$branch_probs$proj_y[row_right]
      d <- self$dataTree$W$d[row]
      cval <- self$dataTree$W$cval[row]
      hval <- self$dataTree$W$hval[row]
      s <- self$dataTree$V$s[node]
      r <- self$dataTree$V$r[node]
      a <- self$dataTree$V$a[node]
      z <- self$dataTree$param$z
      new_proj_x_left <- transform_node(char="x", daughter="left", d=d, m=new_val, c=cval, h=hval, x=0, r=r, s=s, a=a, z=z)
      new_proj_x_right <- transform_node(char="x", daughter="right", d=d, m=new_val, c=cval, h=hval, x=0, r=r, s=s, a=a, z=z)
      new_proj_y_left <- transform_node(char="y", daughter="left", d=d, m=new_val, c=cval, h=hval, y=0, r=r, s=s, a=a, z=z)
      new_proj_y_right <- transform_node(char="y", daughter="right", d=d, m=new_val, c=cval, h=hval, y=0, r=r, s=s, a=a, z=z)
      tips_left <- which(self$dataTree$tree$tip_descendants[self$branch_probs$end_node[row_left],]==1)
      tips_right <- which(self$dataTree$tree$tip_descendants[self$branch_probs$end_node[row_right],]==1)
      new_expected_values <- self$expected_values
      for (i in tips_left) {
        new_expected_values$x[i] <- self$expected_values$x[i] - current_proj_x_left + new_proj_x_left
        new_expected_values$y[i] <- self$expected_values$y[i] - current_proj_y_left + new_proj_y_left
      }
      for (i in tips_right) {
        new_expected_values$x[i] <- self$expected_values$x[i] - current_proj_x_right + new_proj_x_right
        new_expected_values$y[i] <- self$expected_values$y[i] - current_proj_y_right + new_proj_y_right
      }
      new_x_expected <- t(as.matrix(new_expected_values[,1]))
      new_y_expected <- t(as.matrix(new_expected_values[,2]))
      sigma_x <- self$dataTree$param$sigma_x
      sigma_y <- self$dataTree$param$sigma_y
      new_prob_x <- private$get_prob_x(new_x_expected,sigma_x)
      new_prob_y <- private$get_prob_y(new_y_expected,sigma_y)
      new_prob_xy <- new_prob_x + new_prob_y
      new_likelihood <- new_prob_w + new_prob_v + new_prob_xy
      # PRIOR: None
      new_prior <- private$.prior
      # PROPOSAL
      accept <- private$propose(private$.prior, new_prior, private$.likelihood, new_likelihood)
      if (accept) {
        # Updating real values
        self$dataTree$W$m[row] <- new_val
        private$.prob_W <- new_prob_w
        private$.prob_a <- new_prob_a
        private$.prob_V <- new_prob_v
        private$.prob_x <- new_prob_x
        private$.prob_y <- new_prob_y
        private$.prob_XY <- new_prob_xy
        private$.likelihood <- new_likelihood
        private$.prior <- new_prior
        private$.posterior <- private$.prior + private$.likelihood
        # MCMC OBJECTS: expected_values, branches
        private$.expected_values <- new_expected_values
        private$.branch_probs$prob_a[row_left] <- new_branch_prob_left
        private$.branch_probs$prob_a[row_right] <- new_branch_prob_right
        private$.branch_probs$start_a[row_left] <- new_start_left
        private$.branch_probs$start_a[row_right] <- new_start_right
        private$.branch_probs$proj_x[row_left] <- new_proj_x_left
        private$.branch_probs$proj_x[row_right] <- new_proj_x_right
        private$.branch_probs$proj_y[row_left] <- new_proj_y_left
        private$.branch_probs$proj_y[row_right] <- new_proj_y_right
      }

      private$tune(accept)

    }
  },

  #' @description Performs a proposal on W_d (the concentric circle) at one node chosen at random
  propose_w_c = function() {

    node_list <- c((self$dataTree$tree$n_tips+1):self$dataTree$tree$n_nodes)
    target_node <- sample(node_list, 1)
    node_order <- private$get_local(target_node,category="W")
    for (node in node_order) {

      # PARAMETER UPDATES: None

      # PROBABILTIY UPDATES
      # W: prob_w
      row <- node - self$dataTree$tree$n_tips
      c_val = self$dataTree$param$c_val
      current_c <- self$dataTree$W$c[row]
      new_c <- current_c + sample(c(-1,1),size=1)
      if (new_c == -1) {new_c <- length(c_val) - 1}
      if (new_c == length(c_val)) {new_c <- 0}
      new_cval <- c_val[new_c+1]
      current_node_prob_w <- log(self$dataTree$param$rho_c[current_c+1])
      new_node_prob_w <- log(self$dataTree$param$rho_c[new_c+1])
      new_prob_w <- private$.prob_W - current_node_prob_w + new_node_prob_w
      # V: prob_a, prob_v
      row_left <- which(self$branch_probs$start_node == node & self$branch_probs$child == "left")
      row_right <- which(self$branch_probs$start_node == node & self$branch_probs$child == "right")
      a <- self$dataTree$V$a[node]
      length_left <- self$branch_probs$length[row_left]
      length_right <- self$branch_probs$length[row_right]
      end_left <- self$branch_probs$end_a[row_left]
      end_right <- self$branch_probs$end_a[row_right]
      current_branch_prob_left <- self$branch_probs$prob_a[row_left]
      current_branch_prob_right <- self$branch_probs$prob_a[row_right]
      d <- self$dataTree$W$d[row]
      m <- self$dataTree$W$m[row]
      alpha <- self$dataTree$param$alpha
      new_start_left <- transform_node(char="a", daughter="left", d=d, m=m, c=new_cval, a=a, alpha=alpha)
      new_start_right <- transform_node(char="a", daughter="right", d=d, m=m, c=new_cval, a=a, alpha=alpha)
      sigma_a <- self$dataTree$param$sigma_a
      mu <- self$dataTree$param$mu
      kappa <- self$dataTree$param$kappa
      new_branch_prob_left <- private$get_branch_prob_a(new_start_left,end_left,length_left,sigma_a,mu,kappa)
      new_branch_prob_right <- private$get_branch_prob_a(new_start_right,end_right,length_right,sigma_a,mu,kappa)
      new_prob_a <- private$.prob_a - current_branch_prob_left - current_branch_prob_right + new_branch_prob_left + new_branch_prob_right
      new_prob_v <- private$.prob_r + private$.prob_s + new_prob_a
      # XY: prob_x, prob_y, prob_xy
      current_proj_x_left <- self$branch_probs$proj_x[row_left]
      current_proj_x_right <- self$branch_probs$proj_x[row_right]
      current_proj_y_left <- self$branch_probs$proj_y[row_left]
      current_proj_y_right <- self$branch_probs$proj_y[row_right]
      d <- self$dataTree$W$d[row]
      m <- self$dataTree$W$m[row]
      hval <- self$dataTree$W$hval[row]
      s <- self$dataTree$V$s[node]
      r <- self$dataTree$V$r[node]
      a <- self$dataTree$V$a[node]
      z <- self$dataTree$param$z
      new_proj_x_left <- transform_node(char="x", daughter="left", d=d, m=m, c=new_cval, h=hval, x=0, r=r, s=s, a=a, z=z)
      new_proj_x_right <- transform_node(char="x", daughter="right", d=d, m=m, c=new_cval, h=hval, x=0, r=r, s=s, a=a, z=z)
      new_proj_y_left <- transform_node(char="y", daughter="left", d=d, m=m, c=new_cval, h=hval, y=0, r=r, s=s, a=a, z=z)
      new_proj_y_right <- transform_node(char="y", daughter="right", d=d, m=m, c=new_cval, h=hval, y=0, r=r, s=s, a=a, z=z)
      tips_left <- which(self$dataTree$tree$tip_descendants[self$branch_probs$end_node[row_left],]==1)
      tips_right <- which(self$dataTree$tree$tip_descendants[self$branch_probs$end_node[row_right],]==1)
      new_expected_values <- self$expected_values
      for (i in tips_left) {
        new_expected_values$x[i] <- self$expected_values$x[i] - current_proj_x_left + new_proj_x_left
        new_expected_values$y[i] <- self$expected_values$y[i] - current_proj_y_left + new_proj_y_left
      }
      for (i in tips_right) {
        new_expected_values$x[i] <- self$expected_values$x[i] - current_proj_x_right + new_proj_x_right
        new_expected_values$y[i] <- self$expected_values$y[i] - current_proj_y_right + new_proj_y_right
      }
      new_x_expected <- t(as.matrix(new_expected_values[,1]))
      new_y_expected <- t(as.matrix(new_expected_values[,2]))
      sigma_x <- self$dataTree$param$sigma_x
      sigma_y <- self$dataTree$param$sigma_y
      new_prob_x <- private$get_prob_x(new_x_expected,sigma_x)
      new_prob_y <- private$get_prob_y(new_y_expected,sigma_y)
      new_prob_xy <- new_prob_x + new_prob_y
      new_likelihood <- new_prob_w + new_prob_v + new_prob_xy
      # PRIOR: None
      new_prior <- private$.prior
      # PROPOSAL
      accept <- private$propose(private$.prior, new_prior, private$.likelihood, new_likelihood)
      if (accept) {
        # Updating real values
        self$dataTree$W$c[row] <- new_c
        self$dataTree$W$cval[row] <- new_cval
        private$.prob_W <- new_prob_w
        private$.prob_a <- new_prob_a
        private$.prob_V <- new_prob_v
        private$.prob_x <- new_prob_x
        private$.prob_y <- new_prob_y
        private$.prob_XY <- new_prob_xy
        private$.likelihood <- new_likelihood
        private$.prior <- new_prior
        private$.posterior <- private$.prior + private$.likelihood
        # MCMC OBJECTS: expected_values, branches
        private$.expected_values <- new_expected_values
        private$.branch_probs$prob_a[row_left] <- new_branch_prob_left
        private$.branch_probs$prob_a[row_right] <- new_branch_prob_right
        private$.branch_probs$start_a[row_left] <- new_start_left
        private$.branch_probs$start_a[row_right] <- new_start_right
        private$.branch_probs$proj_x[row_left] <- new_proj_x_left
        private$.branch_probs$proj_x[row_right] <- new_proj_x_right
        private$.branch_probs$proj_y[row_left] <- new_proj_y_left
        private$.branch_probs$proj_y[row_right] <- new_proj_y_right
      }

      private$tune(accept)

    }
  },

  #' @description Performs a proposal on W_d (the direction line) at one node chosen at random
  propose_w_h = function() {

    node_list <- c((self$dataTree$tree$n_tips+1):self$dataTree$tree$n_nodes)
    target_node <- sample(node_list, 1)
    node_order <- private$get_local(target_node,category="W")
    for (node in node_order) {

      # PARAMETER UPDATES: None

      # PROBABILTIY UPDATES
      # W: prob_w
      row <- node - self$dataTree$tree$n_tips
      h_val = self$dataTree$param$h_val
      current_h <- self$dataTree$W$h[row]
      new_h <- current_h + sample(c(-1,1),size=1)
      if (new_h == -1) {new_h <- length(h_val) - 1}
      if (new_h == length(h_val)) {new_h <- 0}
      new_hval <- h_val[new_h+1]
      current_node_prob_w <- log(self$dataTree$param$rho_h[current_h+1])
      new_node_prob_w <- log(self$dataTree$param$rho_h[new_h+1])
      new_prob_w <- private$.prob_W - current_node_prob_w + new_node_prob_w
      # V: None
      # XY: prob_x, prob_y, prob_xy
      row_left <- which(self$branch_probs$start_node == node & self$branch_probs$child == "left")
      row_right <- which(self$branch_probs$start_node == node & self$branch_probs$child == "right")
      current_proj_x_left <- self$branch_probs$proj_x[row_left]
      current_proj_x_right <- self$branch_probs$proj_x[row_right]
      current_proj_y_left <- self$branch_probs$proj_y[row_left]
      current_proj_y_right <- self$branch_probs$proj_y[row_right]
      d <- self$dataTree$W$d[row]
      m <- self$dataTree$W$m[row]
      cval <- self$dataTree$W$cval[row]
      s <- self$dataTree$V$s[node]
      r <- self$dataTree$V$r[node]
      a <- self$dataTree$V$a[node]
      z <- self$dataTree$param$z
      new_proj_x_left <- transform_node(char="x", daughter="left", d=d, m=m, c=cval, h=new_hval, x=0, r=r, s=s, a=a, z=z)
      new_proj_x_right <- transform_node(char="x", daughter="right", d=d, m=m, c=cval, h=new_hval, x=0, r=r, s=s, a=a, z=z)
      new_proj_y_left <- transform_node(char="y", daughter="left", d=d, m=m, c=cval, h=new_hval, y=0, r=r, s=s, a=a, z=z)
      new_proj_y_right <- transform_node(char="y", daughter="right", d=d, m=m, c=cval, h=new_hval, y=0, r=r, s=s, a=a, z=z)
      tips_left <- which(self$dataTree$tree$tip_descendants[self$branch_probs$end_node[row_left],]==1)
      tips_right <- which(self$dataTree$tree$tip_descendants[self$branch_probs$end_node[row_right],]==1)
      new_expected_values <- self$expected_values
      for (i in tips_left) {
        new_expected_values$x[i] <- self$expected_values$x[i] - current_proj_x_left + new_proj_x_left
        new_expected_values$y[i] <- self$expected_values$y[i] - current_proj_y_left + new_proj_y_left
      }
      for (i in tips_right) {
        new_expected_values$x[i] <- self$expected_values$x[i] - current_proj_x_right + new_proj_x_right
        new_expected_values$y[i] <- self$expected_values$y[i] - current_proj_y_right + new_proj_y_right
      }
      new_x_expected <- t(as.matrix(new_expected_values[,1]))
      new_y_expected <- t(as.matrix(new_expected_values[,2]))
      sigma_x <- self$dataTree$param$sigma_x
      sigma_y <- self$dataTree$param$sigma_y
      new_prob_x <- private$get_prob_x(new_x_expected,sigma_x)
      new_prob_y <- private$get_prob_y(new_y_expected,sigma_y)
      new_prob_xy <- new_prob_x + new_prob_y
      new_likelihood <- new_prob_w + private$.prob_V + new_prob_xy
      # PRIOR: None
      new_prior <- private$.prior
      # PROPOSAL
      accept <- private$propose(private$.prior, new_prior, private$.likelihood, new_likelihood)
      if (accept) {
        # Updating real values
        self$dataTree$W$h[row] <- new_h
        self$dataTree$W$hval[row] <- new_hval
        private$.prob_W <- new_prob_w
        private$.prob_x <- new_prob_x
        private$.prob_y <- new_prob_y
        private$.prob_XY <- new_prob_xy
        private$.likelihood <- new_likelihood
        private$.prior <- new_prior
        private$.posterior <- private$.prior + private$.likelihood
        # MCMC OBJECTS: expected_values, branches
        private$.expected_values <- new_expected_values
        private$.branch_probs$proj_x[row_left] <- new_proj_x_left
        private$.branch_probs$proj_x[row_right] <- new_proj_x_right
        private$.branch_probs$proj_y[row_left] <- new_proj_y_left
        private$.branch_probs$proj_y[row_right] <- new_proj_y_right
      }

      private$tune(accept)

    }
  }

),

# Active Bindings ---------------------------------------------------------

active = list(

  # Active bindings that return values (stored in private fields)
  # Can also be set by the user (after type checking)
  dataTree = function(value) {
    if (missing(value)) {private$.dataTree}
    else {
      if ("dataTree" %in% class(value)) {
        private$.dataTree = value
      } else {
        stop("tree must be of class dataTree")
      }
    }
  },

  filepath = function(value) {
    if (missing(value)) {private$.filepath}
    else {
      if ("character" %in% class(value)) {
        private$.filepath = value
      } else {
        stop("filepath must be a string")
      }
    }
  },

  prior_sigma_x = function(value) {
    if (missing(value)) {private$.prior_sigma_x}
    else {
      if ("distribution" %in% class(value)) {
        private$.prior_sigma_x = value
      } else {
        stop("prior_sigma_x must be of class distribution")
      }
    }
  },

  prior_sigma_y = function(value) {
    if (missing(value)) {private$.prior_sigma_y}
    else {
      if ("distribution" %in% class(value)) {
        private$.prior_sigma_y = value
      } else {
        stop("prior_sigma_y must be of class distribution")
      }
    }
  },

  prior_sigma_r = function(value) {
    if (missing(value)) {private$.prior_sigma_r}
    else {
      if ("distribution" %in% class(value)) {
        private$.prior_sigma_r = value
      } else {
        stop("prior_sigma_r must be of class distribution")
      }
    }
  },

  prior_sigma_s = function(value) {
    if (missing(value)) {private$.prior_sigma_s}
    else {
      if ("distribution" %in% class(value)) {
        private$.prior_sigma_s = value
      } else {
        stop("prior_sigma_s must be of class distribution")
      }
    }
  },

  prior_sigma_a = function(value) {
    if (missing(value)) {private$.prior_sigma_a}
    else {
      if ("distribution" %in% class(value)) {
        private$.prior_sigma_a = value
      } else {
        stop("prior_sigma_a must be of class distribution")
      }
    }
  },

  prior_root_x = function(value) {
    if (missing(value)) {private$.prior_root_x}
    else {
      if ("distribution" %in% class(value)) {
        private$.prior_root_x = value
      } else {
        stop("prior_root_x must be of class distribution")
      }
    }
  },

  prior_root_y = function(value) {
    if (missing(value)) {private$.prior_root_y}
    else {
      if ("distribution" %in% class(value)) {
        private$.prior_root_y = value
      } else {
        stop("prior_root_y must be of class distribution")
      }
    }
  },

  prior_root_r = function(value) {
    if (missing(value)) {private$.prior_root_r}
    else {
      if ("distribution" %in% class(value)) {
        private$.prior_root_r = value
      } else {
        stop("prior_root_r must be of class distribution")
      }
    }
  },

  prior_root_s = function(value) {
    if (missing(value)) {private$.prior_root_s}
    else {
      if ("distribution" %in% class(value)) {
        private$.prior_root_s = value
      } else {
        stop("prior_root_s must be of class distribution")
      }
    }
  },

  prior_root_a = function(value) {
    if (missing(value)) {private$.prior_root_a}
    else {
      if ("distribution" %in% class(value)) {
        private$.prior_root_a = value
      } else {
        stop("prior_root_a must be of class distribution")
      }
    }
  },

  prior_mu = function(value) {
    if (missing(value)) {private$.prior_mu}
    else {
      if ("distribution" %in% class(value)) {
        private$.prior_mu = value
      } else {
        stop("prior_mu must be of class distribution")
      }
    }
  },

  prior_kappa = function(value) {
    if (missing(value)) {private$.prior_kappa}
    else {
      if ("distribution" %in% class(value)) {
        private$.prior_kappa = value
      } else {
        stop("prior_kappa must be of class distribution")
      }
    }
  },

  proposal_weights = function(value) {
    if (missing(value)) {private$.proposal_weights}
    else {
      if ("list" %in% class(value)) {
        private$.proposal_weights = value
      } else {
        stop("proposal_weights must be of class list")
      }
    }
  },

  # These active bindings cannot be set by the user
  # Will be calculated from the dataTree
  prob_W = function(value) {
    if (missing(value)) {private$.prob_W}
    else {
      stop("prob_W is read-only")
    }
  },

  prob_V = function(value) {
    if (missing(value)) {private$.prob_V}
    else {
      stop("prob_V is read-only")
    }
  },

  prob_XY = function(value) {
    if (missing(value)) {private$.prob_XY}
    else {
      stop("prob_XY is read-only")
    }
  },

  prob_x = function(value) {
    if (missing(value)) {private$.prob_x}
    else {
      stop("prob_x is read-only")
    }
  },

  prob_y = function(value) {
    if (missing(value)) {private$.prob_y}
    else {
      stop("prob_y is read-only")
    }
  },

  prob_r = function(value) {
    if (missing(value)) {private$.prob_r}
    else {
      stop("prob_r is read-only")
    }
  },

  prob_s = function(value) {
    if (missing(value)) {private$.prob_s}
    else {
      stop("prob_s is read-only")
    }
  },

  prob_a = function(value) {
    if (missing(value)) {private$.prob_a}
    else {
      stop("prob_a is read-only")
    }
  },

  expected_values = function(value) {
    if (missing(value)) {private$.expected_values}
    else {
      stop("expected_values is read-only")
    }
  },

  branch_probs = function(value) {
    if (missing(value)) {private$.branch_probs}
    else {
      stop("branch_probs is read-only")
    }
  },

  likelihood = function(value) {
    if (missing(value)) {private$.likelihood}
    else {
      stop("likelihood is read-only")
    }
  },

  prior = function(value) {
    if (missing(value)) {private$.prior}
    else {
      stop("prior is read-only")
    }
  },

  posterior = function(value) {
    if (missing(value)) {private$.posterior}
    else {
      stop("posterior is read-only")
    }
  },

  acceptances = function(value) {
    if (missing(value)) {private$.acceptances}
    else {
      stop("acceptances is read-only")
    }
  },

  completed_iterations = function(value) {
    if (missing(value)) {private$.completed_iterations}
    else {
      stop("completed_iterations is read-only")
    }
  },

  elapsed_time = function(value) {
    if (missing(value)) {private$.elapsed_time}
    else {
      stop("elapsed_time is read-only")
    }
  },

  current_proposal = function(value) {
    if (missing(value)) {private$.current_proposal}
    else {
      stop("current_proposal is read-only")
    }
  },

  testing_conditions = function(value) {
    if (missing(value)) {private$.testing_conditions}
    else {
      if ("character" %in% class(value)) {
        private$.testing_conditions = value
        if ("under_prior" %in% value) {private$UNDER_PRIOR <- TRUE} else {private$UNDER_PRIOR <- FALSE}
        if ("test_probs" %in% value) {private$TEST_PROBS <- TRUE} else {private$TEST_PROBS <- FALSE}
        if ("record_proposals" %in% value) {private$RECORD_PROPOSALS <- TRUE} else {private$RECORD_PROPOSALS <- FALSE}
      } else {
        stop("testing_conditions must be of class character")
      }
    }
  }
),

# Public Fields & Methods -------------------------------------------------

public = list(

  #' @description Creates a new instance of the ellipseMCMC class
  #' @param dataTree An object of class "dataTree"
  #' @param prior_sigma_x Prior on the sigma_x model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Uniform(0,1)
  #' @param prior_sigma_y Prior on the sigma_y model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Uniform(0,1)
  #' @param prior_sigma_r Prior on the sigma_r model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Uniform(0,1)
  #' @param prior_sigma_s Prior on the sigma_s model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Uniform(0,1)
  #' @param prior_sigma_a Prior on the sigma_a model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Uniform(0,5)
  #' @param prior_root_x Prior on the root_x model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Normal(0,1)
  #' @param prior_root_y Prior on the root_y model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Normal(0,1)
  #' @param prior_root_r Prior on the root_r model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Normal(0,5)
  #' @param prior_root_s Prior on the root_s model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Normal(0,5)
  #' @param prior_root_a Prior on the root_a model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Uniform(-5,10)
  #' @param prior_mu Prior on the mu model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Uniform(-5,10)
  #' @param prior_kappa Prior on the kappa model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Uniform(0,5)
  #' @param proposal_weights A list of MCMC proposals and their relative weights (can use proportions or whole numbers). If you want to exclude a proposal, the weight can be set to 0
  initialize = function(dataTree=NULL,
                        # Default distributions provided
                        prior_sigma_x=distributions3::Uniform(0,1),
                        prior_sigma_y=distributions3::Uniform(0,1),
                        prior_sigma_r=distributions3::Uniform(0,1),
                        prior_sigma_s=distributions3::Uniform(0,1),
                        prior_sigma_a=distributions3::Uniform(0,5),
                        prior_root_x=distributions3::Normal(0,1),
                        prior_root_y=distributions3::Normal(0,1),
                        prior_root_r=distributions3::Normal(0,5),
                        prior_root_s=distributions3::Normal(0,5),
                        prior_root_a=distributions3::Uniform(-5,10),
                        prior_mu=distributions3::Uniform(-5,10),
                        prior_kappa=distributions3::Uniform(0,5),
                        proposal_weights=list(sigma_x=10,sigma_y=10,sigma_r=5,sigma_s=5,sigma_a=5,root_x=1,root_y=1,root_r=1,root_s=1,root_a=1,mu=5,kappa=5,W_d=5,W_m=5,W_c=5,W_h=5,V_r=10,V_s=10,V_a=10,tip=10)) {

    # Setting fields with user input (active bindings will do type checking)
    self$dataTree <- dataTree
    self$prior_sigma_x <- prior_sigma_x
    self$prior_sigma_y <- prior_sigma_y
    self$prior_sigma_r <- prior_sigma_r
    self$prior_sigma_s <- prior_sigma_s
    self$prior_sigma_a <- prior_sigma_a
    self$prior_root_x <- prior_root_x
    self$prior_root_y <- prior_root_y
    self$prior_root_r <- prior_root_r
    self$prior_root_s <- prior_root_s
    self$prior_root_a <- prior_root_a
    self$prior_mu <- prior_mu
    self$prior_kappa <- prior_kappa
    self$proposal_weights <- proposal_weights

    # Building list of proposals, acceptances, current acceptance ratios, and hyperparameters
    # Associated with each proposal type
    private$.acceptances = list(sigma_x=list(proposed=0,accepted=0,accumulated=0,current_prob=0,hyperparam=0.05),
                            sigma_y=list(proposed=0,accepted=0,accumulated=0,current_prob=0,hyperparam=0.05),
                            sigma_r=list(proposed=0,accepted=0,accumulated=0,current_prob=0,hyperparam=0.025),
                            sigma_s=list(proposed=0,accepted=0,accumulated=0,current_prob=0,hyperparam=0.025),
                            sigma_a=list(proposed=0,accepted=0,accumulated=0,current_prob=0,hyperparam=0.01),
                            mu=list(proposed=0,accepted=0,accumulated=0,current_prob=0,hyperparam=0.1),
                            kappa=list(proposed=0,accepted=0,accumulated=0,current_prob=0,hyperparam=.01),
                            root_x=list(proposed=0,accepted=0,accumulated=0,current_prob=0,hyperparam=0.1),
                            root_y=list(proposed=0,accepted=0,accumulated=0,current_prob=0,hyperparam=0.1),
                            root_r=list(proposed=0,accepted=0,accumulated=0,current_prob=0,hyperparam=0.1),
                            root_s=list(proposed=0,accepted=0,accumulated=0,current_prob=0,hyperparam=0.1),
                            root_a=list(proposed=0,accepted=0,accumulated=0,current_prob=0,hyperparam=0.1),
                            tip=list(proposed=0,accepted=0,accumulated=0,current_prob=0,hyperparam=NULL),
                            V_r=list(proposed=0,accepted=0,accumulated=0,current_prob=0,hyperparam=0.1),
                            V_s=list(proposed=0,accepted=0,accumulated=0,current_prob=0,hyperparam=0.1),
                            V_a=list(proposed=0,accepted=0,accumulated=0,current_prob=0,hyperparam=0.1),
                            W_d=list(proposed=0,accepted=0,accumulated=0,current_prob=0,hyperparam=NULL),
                            W_m=list(proposed=0,accepted=0,accumulated=0,current_prob=0,hyperparam=NULL),
                            W_c=list(proposed=0,accepted=0,accumulated=0,current_prob=0,hyperparam=NULL),
                            W_h=list(proposed=0,accepted=0,accumulated=0,current_prob=0,hyperparam=NULL))

    # get new param object if none is provided
    if (is.null(self$dataTree$param)) {self$dataTree$param = ellipseParam$new()}
    # simulate data if none is provided
    if (is.null(self$dataTree$W)) {self$dataTree$sim_W()}
    if (is.null(self$dataTree$V)) {self$dataTree$sim_V()}
    if (is.null(self$dataTree$XY)) {self$dataTree$sim_XY()}
    # initialize data augmented values if only tip data is provided
    if (is.na(self$dataTree$V$node[self$dataTree$tree$n_nodes])) {self$dataTree$init_V()}
    if (is.na(self$dataTree$XY$node[self$dataTree$tree$n_nodes])) {self$dataTree$init_XY()}
    # making sure root values match initialized data-augmented values
    self$dataTree$param$root_x <- self$dataTree$XY$x[self$dataTree$tree$n_tips + 1]
    self$dataTree$param$root_y <- self$dataTree$XY$y[self$dataTree$tree$n_tips + 1]
    self$dataTree$param$root_r <- self$dataTree$V$r[self$dataTree$tree$n_tips + 1]
    self$dataTree$param$root_s <- self$dataTree$V$s[self$dataTree$tree$n_tips + 1]
    self$dataTree$param$root_a <- self$dataTree$V$a[self$dataTree$tree$n_tips + 1]
    # get initial prior probability
    private$.prior = private$get_prior()
    if (!(private$.prior!=-Inf)) {stop("Initial log prior is -Inf")}
    if (!(private$.prior!=-Inf)) {stop("Initial log prior is Inf")}
    # get initial model probability
    # data-augmented W probability
    private$.prob_W = get_prob_w(self$dataTree)
    # branchwise values
    branch_probs <- data.frame(self$dataTree$tree$edges)
    colnames(branch_probs) <- c("start_node","end_node","length")
    nodes <- self$dataTree$tree$nodes
    for (i in 1:length(branch_probs$start_node)) {
      start_node <- branch_probs$start_node[i]
      end_node <- branch_probs$end_node[i]
      length <- branch_probs$length[i]
      if (nodes$right_child[start_node] == end_node) {child <- "right"} else {child <- "left"}
      sigma_r <- self$dataTree$param$sigma_r
      sigma_s <- self$dataTree$param$sigma_s
      sigma_a <- self$dataTree$param$sigma_a
      mu <- self$dataTree$param$mu
      kappa <- self$dataTree$param$kappa
      into_a <- self$dataTree$V$a[start_node]
      d <- self$dataTree$W$d[which(self$dataTree$W$node == start_node)]
      m <- self$dataTree$W$m[which(self$dataTree$W$node == start_node)]
      c <- self$dataTree$W$cval[which(self$dataTree$W$node == start_node)]
      h <- self$dataTree$W$hval[which(self$dataTree$W$node == start_node)]
      start_r <- self$dataTree$V$r[start_node]
      start_s <- self$dataTree$V$s[start_node]
      start_a <- transform_node(char="a", daughter=child, d=d, m=m, c=c, h=h, x=NULL, y=NULL, r=start_r, s=start_s, a=into_a, alpha=self$dataTree$param$alpha, z=self$dataTree$param$z)
      end_r <- self$dataTree$V$r[end_node]
      end_s <- self$dataTree$V$s[end_node]
      end_a <- self$dataTree$V$a[end_node]
      prob_r <- dnorm(end_r, start_r, sigma_r*sqrt(length),log=TRUE)
      prob_s <- dnorm(end_s, start_s, sigma_s*sqrt(length),log=TRUE)
      prob_a <- dnorm(end_a, mu + (start_a - mu) * exp(-1 * kappa * length), sqrt(sigma_a^2 / (2 * kappa) * (1 - exp(-2 * kappa * length))),log=TRUE)
      # projections from cladogenetic scenarios
      proj_x <- transform_node(char="x", daughter=child, d=d, m=m, c=c, h=h, x=0, y=0, r=start_r, s=start_s, a=into_a, alpha=self$dataTree$param$alpha, z=self$dataTree$param$z)
      proj_y <- transform_node(char="y", daughter=child, d=d, m=m, c=c, h=h, x=0, y=0, r=start_r, s=start_s, a=into_a, alpha=self$dataTree$param$alpha, z=self$dataTree$param$z)
      # recording values
      branch_probs$child[i] <- child
      branch_probs$start_r[i] <- start_r
      branch_probs$start_s[i] <- start_s
      branch_probs$start_a[i] <- start_a
      branch_probs$end_r[i] <- end_r
      branch_probs$end_s[i] <- end_s
      branch_probs$end_a[i] <- end_a
      branch_probs$prob_r[i] <- prob_r
      branch_probs$prob_s[i] <- prob_s
      branch_probs$prob_a[i] <- prob_a
      branch_probs$proj_x[i] <- proj_x
      branch_probs$proj_y[i] <- proj_y
    }
    private$.branch_probs <- branch_probs
    # data-augmented V probabilities
    private$.prob_V <- get_prob_v(self$dataTree)
    private$.prob_r <- sum(self$branch_probs$prob_r)
    private$.prob_s <- sum(self$branch_probs$prob_s)
    private$.prob_a <- sum(self$branch_probs$prob_a)
    # expected values
    expectations <- data.frame(get_expectations(self$dataTree$tree,self$dataTree$param,self$dataTree$XY,self$dataTree$W,self$dataTree$V))
    colnames(expectations) <- c("x","y")
    private$.expected_values <- expectations
    # XY probabilities
    private$.prob_XY = get_prob_xy(self$dataTree)
    n_tips <- self$dataTree$tree$n_tips
    inv <- self$dataTree$tree$inv_matrix
    matrix <- self$dataTree$tree$phy_matrix
    matrix_det <- unlist(determinant(matrix,logarithm=TRUE))[[1]]
    x_data <- t(as.matrix(self$dataTree$XY$x))[1:n_tips]
    x_expected <- t(as.matrix(self$expected_values[,1]))
    x <- x_data - x_expected
    y_data <- t(as.matrix(self$dataTree$XY$y))[1:n_tips]
    y_expected <- t(as.matrix(self$expected_values[,2]))
    y <- y_data - y_expected
    private$.prob_x <- (-1/2) * (length(x) * log(2 * pi) + length(x) * 2 * log(self$dataTree$param$sigma_x) + matrix_det + x %*% ((1 / self$dataTree$param$sigma_x^2) * inv) %*% t(x))
    private$.prob_y <- (-1/2) * (length(y) * log(2 * pi) + length(y) * 2 * log(self$dataTree$param$sigma_y) + matrix_det + y %*% ((1 / self$dataTree$param$sigma_y^2) * inv) %*% t(y))
    # initial total likelihood
    private$.likelihood = get_prob(self$dataTree)
    if (!(private$.likelihood!=-Inf)) {stop("Initial log likelihood is -Inf")}
    if (!(private$.likelihood!=-Inf)) {stop("Initial log likelihood is Inf")}
    # get initial posterior
    private$.posterior = private$.prior + private$.likelihood
    if (!(private$.posterior!=-Inf)) {stop("Initial log posterior is -Inf")}
    if (!(private$.posterior!=-Inf)) {stop("Initial log posterior is Inf")}
  },

  #' @description Runs an MCMC analysis
  #' @param iterations The number of iterations to run the analysis. If a number of burnin generations is also provided, some of these iterations will be burnin (recorded, but should be discarded due to tuning proposal hyperparameters)
  #' @param moves_per_iteration The number of moves per iteration (total number of proposals for one iteration). The default value is 1.
  #' @param burnin The number of generations that should be used for tuning burnin. These generations will still be saved. The default value is 0.
  #' @param thinning How often the mcmc output is recorded, for example (thinning=10) will record every 10 generations. The default value is 1.
  #' @param filepath An object of class "character" (a string) that gives the filepath where you want the output log files saved. Default behavior will save the output to the same directory where the mcmc is run.
  #' @param testing_conditions A list of extra testing conditions. Options include c("under_prior", "test_probs", "record_proposals")
  run = function(iterations,moves_per_iteration=1,burnin=0,thinning=1,testing_conditions=c("none"),filepath=".") {
    # Type checking for user input to run MCMC
    if (!("numeric" %in% class(iterations))) {stop("iterations must be numeric")}
    if (!("numeric" %in% class(moves_per_iteration))) {stop("moves_per_iteration must be numeric")}
    if (!("numeric" %in% class(burnin))) {stop("burnin must be numeric")}
    if (!("numeric" %in% class(thinning))) {stop("thinning must be numeric")}
    if (!(iterations==round(iterations))) {stop("iterations must be a natural number")}
    if (!(moves_per_iteration==round(moves_per_iteration))) {stop("moves_per_iteration must be a natural number")}
    if (!(burnin==round(burnin))) {stop("burnin must be a natural number")}
    if (!(thinning==round(thinning))) {stop("thinning must be a natural number")}
    # Setting run conditions (testing_conditions and filepath) if provided
    self$testing_conditions <- testing_conditions
    self$filepath <- filepath
    # Setting start time & completed iterations
    private$.completed_iterations = 0
    private$PREVIOUS_TIME = Sys.time()
    # Making sure save directory is present
    dir.create(file.path(self$filepath), showWarnings = FALSE, recursive=TRUE)
    # Setting up header for screen output and logfile
    header <- paste("Iteration", "Posterior", "Likelihood", "Prior", "sigma_x", "sigma_y", "sigma_r", "sigma_s", "sigma_a", "root_x", "root_y", "root_r", "root_s", "root_a", "mu", "kappa", "Time", "ETA", sep="\t")
    cat(header,"\n")
    write(header,paste0(self$filepath,"/model_log.tsv"))
    # Starting files to log data-augmented values at nodes
    length_W = length(self$dataTree$W$node)
    length_V = length(self$dataTree$V$node)
    length_XY = length(self$dataTree$XY$node)
    write(c("Iteration",self$dataTree$W$node),paste0(self$filepath,"/h_log.tsv"),ncolumns=(1+length_W),sep="\t")
    write(c("Iteration",self$dataTree$W$node),paste0(self$filepath,"/c_log.tsv"),ncolumns=(1+length_W),sep="\t")
    write(c("Iteration",self$dataTree$W$node),paste0(self$filepath,"/m_log.tsv"),ncolumns=(1+length_W),sep="\t")
    write(c("Iteration",self$dataTree$W$node),paste0(self$filepath,"/d_log.tsv"),ncolumns=(1+length_W),sep="\t")
    write(c("Iteration",self$dataTree$V$node),paste0(self$filepath,"/r_log.tsv"),ncolumns=(1+length_V),sep="\t")
    write(c("Iteration",self$dataTree$V$node),paste0(self$filepath,"/s_log.tsv"),ncolumns=(1+length_V),sep="\t")
    write(c("Iteration",self$dataTree$V$node),paste0(self$filepath,"/a_log.tsv"),ncolumns=(1+length_V),sep="\t")
    write(c("Iteration",self$dataTree$XY$node),paste0(self$filepath,"/x_log.tsv"),ncolumns=(1+length_XY),sep="\t")
    write(c("Iteration",self$dataTree$XY$node),paste0(self$filepath,"/y_log.tsv"),ncolumns=(1+length_XY),sep="\t")

    ######################################
    ########## ACTUAL MCMC LOOP ##########
    ######################################

    for (iteration in 1:iterations) {
      # Checking if we're in the burnin phase and setting the private TUNING field appropriately
      if (iteration <= burnin) {private$TUNING=TRUE} else {private$TUNING=FALSE}
      # Doing proposals for this iteration (may be more than one proposal per iteration)
      if (iteration != 1) {for (move in 1:moves_per_iteration) {private$do_proposal()}}
      if (((private$.completed_iterations+1) / thinning) == round((private$.completed_iterations+1) / thinning)) {self$dataTree$reconstruct()}
      if (private$TEST_PROBS) {private$test_probs()}
      # Saving iteration (if it is not thinned)
      tryCatch(private$save_iteration(length_W,length_V,length_XY,iteration,thinning,iterations),
               interrupt=function(i) {private$save_iteration(length_W,length_V,length_XY,iteration,thinning,iterations)}
      )
    }
  },

  #' @description Continues an MCMC analysis
  #' @param iterations The number of iterations to run the analysis. None of these iterations will be used as burnin, and hyperparameters will not be further tuned.
  #' @param moves_per_iteration The number of moves per iteration (total number of proposals for one iteration). The default value is 1.
  #' @param thinning How often the mcmc output is recorded, for example (thinning=10) will record every 10 generations. The default value is 1.
  #' @param testing_conditions A list of extra testing conditions. Options include c("under_prior", "test_probs", "record_proposals"). If no values are provided, the analysis will continue using the preexisting testing conditions.
  continue = function(iterations,moves_per_iteration=1,thinning=1,testing_conditions=NULL) {
    # Type checking for user input to run MCMC
    if (!("numeric" %in% class(iterations))) {stop("iterations must be numeric")}
    if (!("numeric" %in% class(moves_per_iteration))) {stop("moves_per_iteration must be numeric")}
    if (!("numeric" %in% class(thinning))) {stop("thinning must be numeric")}
    if (!(iterations==round(iterations))) {stop("iterations must be a natural number")}
    if (!(moves_per_iteration==round(moves_per_iteration))) {stop("moves_per_iteration must be a natural number")}
    if (!(thinning==round(thinning))) {stop("thinning must be a natural number")}
    if (!is.null(testing_conditions)) {self$testing_conditions <- testing_conditions}
    # Setting start time
    private$PREVIOUS_TIME = Sys.time()

    ######################################
    ########## ACTUAL MCMC LOOP ##########
    ######################################

    length_W = length(self$dataTree$W$node)
    length_V = length(self$dataTree$V$node)
    length_XY = length(self$dataTree$XY$node)
    total_iterations = private$.completed_iterations+iterations

    for (iteration in (private$.completed_iterations+1):total_iterations) {
      private$TUNING <- FALSE
      # Doing proposals for this iteration (may be more than one proposal per iteration)
      for (move in 1:moves_per_iteration) {private$do_proposal()}
      if (((private$.completed_iterations+1) / thinning) == round((private$.completed_iterations+1) / thinning)) {self$dataTree$reconstruct()}
      if (private$TEST_PROBS) {private$test_probs()}
      # Saving iteration (if it is not thinned)
      tryCatch(private$save_iteration(length_W,length_V,length_XY,iteration,thinning,total_iterations),
               interrupt=function(i) {private$save_iteration(length_W,length_V,length_XY,iteration,thinning,total_iterations)}
      )
    }
  }

))


# Functions ---------------------------------------------------------------

#' @title make_MCMC function
#' @description Creates a new instance of the ellipseMCMC class
#' @param dataTree An object of class "dataTree"
#' @param prior_sigma_x Prior on the sigma_x model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Uniform(0,1)
#' @param prior_sigma_y Prior on the sigma_y model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Uniform(0,1)
#' @param prior_sigma_r Prior on the sigma_r model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Uniform(0,1)
#' @param prior_sigma_s Prior on the sigma_s model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Uniform(0,1)
#' @param prior_sigma_a Prior on the sigma_a model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Uniform(0,5)
#' @param prior_root_x Prior on the root_x model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Normal(0,1)
#' @param prior_root_y Prior on the root_y model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Normal(0,1)
#' @param prior_root_r Prior on the root_r model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Normal(0,5)
#' @param prior_root_s Prior on the root_s model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Normal(0,5)
#' @param prior_root_a Prior on the root_a model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Uniform(-5,10)
#' @param prior_mu Prior on the mu model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Uniform(-5,10)
#' @param prior_kappa Prior on the kappa model parameter. Should be an object of type "distribution" generated by using the package "distributions3". Default is Uniform(0,5)
#' @param proposal_weights A list of MCMC proposals and their relative weights (can use proportions or whole numbers). If you want to exclude a proposal, the weight can be set to 0
make_MCMC = function(dataTree=NULL,
                     # Default distributions provided
                     prior_sigma_x=distributions3::Uniform(0,1),
                     prior_sigma_y=distributions3::Uniform(0,1),
                     prior_sigma_r=distributions3::Uniform(0,1),
                     prior_sigma_s=distributions3::Uniform(0,1),
                     prior_sigma_a=distributions3::Uniform(0,5),
                     prior_root_x=distributions3::Normal(0,1),
                     prior_root_y=distributions3::Normal(0,1),
                     prior_root_r=distributions3::Normal(0,5),
                     prior_root_s=distributions3::Normal(0,5),
                     prior_root_a=distributions3::Uniform(-5,10),
                     prior_mu=distributions3::Uniform(-5,10),
                     prior_kappa=distributions3::Uniform(0,5),
                     proposal_weights=list(sigma_x=10,sigma_y=10,sigma_r=10,sigma_s=10,sigma_a=10,root_x=1,root_y=1,root_r=1,root_s=1,root_a=1,mu=10,kappa=10,W_d=10,W_m=10,W_c=10,W_h=10,V_r=20,V_s=20,V_a=20,tip=10)) {
  MCMC = ellipseMCMC$new(dataTree,prior_sigma_x,prior_sigma_y,prior_sigma_r,prior_sigma_s,prior_sigma_a,prior_root_x,prior_root_y,prior_root_r,prior_root_s,prior_root_a,prior_mu,prior_kappa,proposal_weights)
  return(MCMC)
}

#' @title run_MCMC function
#' @description Runs an MCMC analysis
#' @param mcmc The ellipseMCMC object to run
#' @param iterations The number of iterations to run the analysis. If a number of burnin generations is also provided, some of these iterations will be burnin (recorded, but should be discarded due to tuning proposal hyperparameters)
#' @param moves_per_iteration The number of moves per iteration (total number of proposals for one iteration). The default value is 1.
#' @param burnin The number of generations that should be used for tuning burnin. These generations will still be saved.
#' @param thinning How often the mcmc output is recorded, for example (thinning=10) will record every 10 generations. The default value is 1.
#' @param testing_conditions A list of extra testing conditions. Options include c("under_prior", "test_probs", "record_proposals")
#' @param filepath An object of class "character" (a string) that gives the filepath where you want the output log files saved. Default behavior will save the output to the same directory where the mcmc is run.
run_MCMC = function(mcmc,iterations,moves_per_iteration=1,burnin=0,thinning=1,under_prior=NULL,testing_conditions=c("none"),filepath=".") {
  mcmc$run(iterations,moves_per_iteration,burnin,thinning,testing_conditions,filepath)
}

#' @title continue_MCMC function
#' @description Continues an MCMC analysis
#' @param mcmc The ellipseMCMC object to run
#' @param iterations The number of iterations to run the analysis. None of these iterations will be used as burnin, and hyperparameters will not be further tuned.
#' @param moves_per_iteration The number of moves per iteration (total number of proposals for one iteration). The default value is 1.
#' @param thinning How often the mcmc output is recorded, for example (thinning=10) will record every 10 generations. The default value is 1.
#' @param testing_conditions A list of extra testing conditions. Options include c("under_prior", "test_probs", "record_proposals"). If no values are provided, the analysis will continue using the preexisting testing conditions.
continue_MCMC = function(mcmc,iterations,moves_per_iteration=1,thinning=1,testing_conditions=NULL) {
  mcmc$continue(iterations,moves_per_iteration,thinning,testing_conditions)
}
